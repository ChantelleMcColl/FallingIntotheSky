<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>Falling into the sky...</title>

<script type="text/bitsyGameData" id="exportedGameData">
Falling into the sky...

# BITSY VERSION 7.12

! ROOM_FORMAT 1

PAL 0
NAME blueprint
0,82,204
128,159,255
255,255,255

PAL 1
240,147,197
126,119,125
0,0,0

PAL 2
240,147,197
126,119,125
0,0,0

PAL 3
240,147,197
126,119,125
0,0,0

PAL 4
240,147,197
126,119,125
0,0,0

PAL 5
240,147,197
126,119,125
0,0,0

PAL 6
240,147,197
126,119,125
0,0,0

PAL 7
240,147,197
126,119,125
0,0,0

PAL 8
240,147,197
126,119,125
0,0,0

PAL 9
240,147,197
126,119,125
0,0,0

PAL a
240,147,197
126,119,125
0,0,0

PAL b
240,147,197
126,119,125
0,0,0

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME example room
PAL 0

ROOM 1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
2,3,4,5,6,7,8,9,b,c,d,e,f,g,h,i
j,k,k,k,k,k,k,l,m,n,o,p,q,r,s,t
u,0,0,0,w,x,x,x,x,x,x,x,x,x,y,z
10,11,12,13,14,15,11,11,11,11,11,11,11,11,16,17
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,18
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
NAME Hallway
EXT 8,8 2 7,14
PAL 1

ROOM 2
0,0,0,0,0,0,19,1a,1b,0,0,0,0,0,0,0
0,0,0,0,1c,1d,1e,1f,1g,1h,1i,0,0,0,0,0
0,0,0,1j,1k,1l,1m,1n,1o,1p,1q,1r,1s,1t,0,0
1u,1v,1w,1x,1y,1z,20,21,22,1,23,24,25,26,27,0
28,29,2a,2b,1,1,2c,2d,2e,1,2f,2g,1,2h,2i,0
2j,2k,2l,2m,2n,2o,2p,2q,2r,2s,2t,2u,2v,2w,2x,2y
2z,30,31,32,33,34,35,36,37,38,39,3a,3b,3c,3d,3e
0,3f,0,0,0,0,3g,3h,3i,3j,0,0,0,0,0,0
0,0,0,0,0,0,3k,3l,0,0,0,0,0,0,0,0
0,0,0,0,0,0,3m,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,3n,3o,0,0,0,0,0,0,0,0
0,0,0,0,0,3p,3q,3r,3s,3t,3u,3v,3w,3x,3y,0
0,0,0,0,0,3z,40,41,42,43,44,45,46,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,1a6,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Tree
EXT 7,14 3 3,10
PAL 2

ROOM 3
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,47,48,1b,0,0,0,0,0,0
0,0,0,0,0,0,49,4a,4b,4c,0,0,4d,0,0,0
0,0,1u,1b,0,0,0,4e,4f,u,0,4g,4h,0,0,0
0,4i,4j,4k,4l,0,0,4m,4n,4o,4p,4q,4r,0,0,0
0,4s,4t,4u,4v,4w,4x,4y,1a6,50,51,52,53,54,55,0
0,56,57,58,59,5a,5b,0,3z,5c,5d,5e,5f,5g,5h,0
0,0,5i,5j,5k,5l,5m,5n,5o,5p,5q,5r,5s,5t,5u,0
0,0,0,0,0,0,0,0,5m,5v,x,5w,5x,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Hallway2
EXT 8,10 4 2,7
PAL 3

ROOM 4
v,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,5y,5y,5y,5y,5y,5y,5y,5y,5y
1,1,1,1,1,1,1,5z,60,61,62,63,64,65,66,67
68,69,6a,6b,6c,6d,1,6e,6f,6g,6h,6i,6j,6k,6l,6m
u,6n,1,6o,6p,6q,6r,6s,6t,6u,6v,6w,6x,6y,6z,70
71,72,1,73,74,75,76,77,78,79,7a,7b,7c,7d,7e,7f
1,1,1a6,7g,7h,7i,7j,7k,7l,7m,7n,7o,7p,7q,7r,7s
7t,7u,7v,7w,7x,7y,7z,80,81,82,83,84,85,86,87,88
89,8a,8b,8c,8d,8e,8f,8g,8h,8i,8j,8k,8l,0,8n,8o
8p,8q,8r,8s,8t,8u,8v,8w,8x,0,8y,8z,90,0,91,92
93,94,95,96,97,98,99,9a,9b,9c,9d,9e,9f,9g,9h,9i
9j,9k,9l,9m,9n,9o,1,9p,9q,9r,9s,9t,9u,9v,9w,9x
1,1,9y,9z,a0,1,1,a1,1,a2,a3,a4,a5,a6,a7,a8
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
NAME Living Room
EXT 2,7 5 6,11
EXT 2,7 5 6,11
PAL 4

ROOM 5
0,0,0,0,0,a9,aa,0,0,0,0,0,0,0,0,0
0,0,0,0,0,ab,ac,ad,0,0,0,0,0,0,0,0
0,0,ae,af,ag,ah,ai,aj,ak,al,0,0,0,0,0,0
0,0,am,an,ao,ap,aq,ar,as,at,0,0,0,0,0,0
0,0,au,av,aw,ax,1a6,az,b0,b1,0,0,0,0,0,0
0,0,0,b2,b3,0,0,b4,b5,b6,0,0,0,0,0,0
0,0,0,0,0,b7,b8,b9,ba,bb,bc,0,0,0,0,0
0,0,0,0,0,0,bd,be,bf,bg,bh,bi,0,0,0,0
0,0,0,0,0,0,bj,bk,bl,bm,bn,bo,bp,bq,0,0
0,0,0,1u,br,bs,bt,bu,0,bv,bw,bx,by,bz,c0,0
0,0,c1,c2,c3,c4,c5,c6,0,1u,c7,c8,c9,ca,cb,0
0,0,cc,cd,ce,cf,1a6,ch,0,ci,cj,ck,cl,0,0,0
0,0,cm,cn,co,cp,cq,cr,cs,ct,cu,cv,0,0,0,0
0,0,0,0,cm,cw,cx,cy,cz,d0,d1,d2,0,0,0,0
0,0,0,0,0,0,d3,d4,d5,d6,d7,0,0,0,0,0
0,0,0,0,0,0,0,d8,d7,0,0,0,0,0,0,0
NAME Hallway3
EXT 6,4 8 10,12
PAL 5

ROOM 6
8m,d9,da,db,dc,dd,de,df,dg,dh,df,di,dj,dk,dl,dm
dn,do,dp,dq,dr,ds,dt,du,dv,dw,dx,dy,dz,e0,e1,e2
e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef,eg,eh,ei
ej,ek,el,em,en,eo,ep,eq,er,es,et,eu,ev,ew,ex,ey
ez,f0,f1,f2,f3,f4,f5,f6,f7,f8,f9,fa,fb,fc,fd,fe
ff,fg,fh,fi,fj,fk,fl,fm,fn,fo,fp,fq,fr,fs,ft,fu
fv,fw,fx,fy,fz,1,g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
ga,gb,gc,gd,ge,1,gf,gg,gh,gi,gj,gk,gl,gm,gn,go
gp,gq,gr,gs,gt,1,gu,gv,gw,gx,gy,gz,h0,h1,h2,h3
h4,h5,h6,h7,1,1,h8,h9,ha,hb,hc,hd,he,hf,hg,hh
hi,hj,hk,1,1,1,1,hl,hm,hn,ho,hp,hq,hr,hs,ht
1,hu,hv,1,1,1,1,1,hw,hx,hy,hz,i0,i1,i2,i3
1,i4,1,1,1,1,1,i5,i6,i7,i8,i9,ia,ib,ic,id
ie,if,ig,ih,ii,ij,ik,il,im,in,io,1,1,ip,iq,ir
is,it,iu,iv,iw,ix,iy,iz,j0,j1,j2,j3,1,j4,1a6,j6
j7,j8,j9,ja,jb,jc,jd,je,jf,jg,jh,ji,1,jj,jk,jl
NAME OuterWorld
ITM 8 10,14
EXT 14,14 9 0,13
PAL 6

ROOM 7
0,jn,0,0,jo,jp,jq,jr,js,jt,ju,jv,jw,jx,jy,jz
0,k0,0,0,k1,k2,k3,k3,k3,k4,k5,k6,k7,k8,0,k9
0,0,0,ka,kb,1,kc,kd,ke,kf,kg,kh,ki,kj,kk,kl
0,0,0,0,km,kn,ko,kp,kq,kr,ks,kt,ku,kv,0,0
kw,kx,ky,kz,l0,l1,l2,0,0,0,l3,0,0,l4,l5,l5
0,l6,l7,l8,l9,la,lb,lc,ld,le,0,0,lf,lg,lh,0
li,lj,lk,ll,lm,5l,0,0,0,0,0,0,ln,0,0,0
lo,0,lp,0,lq,lr,ls,lt,lu,lv,lw,lx,ly,lz,kj,m0
0,0,0,m1,m2,m3,1,1,1,1,m4,m5,m6,m7,m8,0
0,m9,0,0,ma,mb,1,1,1,1,1,mc,md,me,mf,mg
0,0,0,0,0,mh,1,1,1,1,1,mi,0,0,mj,mk
0,0,0,0,ml,mm,1,1,1,1,1,1,mn,0,0,0
0,0,0,0,mo,mp,1,1,1,1,1,1,mq,mr,0,0
0,0,0,ms,1,1,1,1,1,1,1,1,1,mt,mu,0
0,mv,mw,mx,1,1,1,1,1,1,1,1,1,1,my,mz
n0,n1,1,1,1,1,1,1,1a6,1,1,1,1,1,1,1
NAME Cliff
ITM 6 6,12
ITM 7 10,9
PAL 7

ROOM 8
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,jm,1,1,1,1,1,1,1,1
1,1,1,1,1,n2,n3,n4,n5,n6,1,1,1,1,1,1
1,1,1,n7,n8,n9,na,nb,nc,nd,ne,nf,1,1,1,1
1,1,ng,nh,ni,nj,nk,nl,nm,nn,no,np,nq,1,1,1
1,1,nr,ns,nt,nu,nv,nw,nx,ny,nz,o0,o1,1,1,1
1,1,o2,o3,o4,o5,o6,o7,o8,o9,oa,ob,oc,1,1,1
1,1,od,oe,of,og,oh,oi,oj,ok,ol,om,oc,1,1,1
1,1,on,oo,op,oq,or,os,ot,ou,ov,ow,oc,1,1,1
1,1,ox,oy,oz,p0,p1,p2,p3,p4,p5,p6,p7,1,1,1
1,1,p8,p9,pa,pb,pc,pd,pe,0,pg,ph,pi,1,1,1
1,1,pj,pk,pl,pm,pn,po,pp,pq,pr,ps,pt,1,1,1
1,1,pu,pv,pw,px,py,pz,q0,q1,1a6,q3,q4,1,1,1
1,1,1,1,q5,q6,q7,q8,q9,qa,qb,1,1,1,1,1
1,1,1,1,1,1,qc,qd,qe,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
NAME Bedroom
ITM 2 7,10
PAL 8

ROOM 9
i5,pf,qf,1,qg,qh,qi,qj,qk,ql,qm,qn,qo,qp,qq,qr
qs,qt,qu,qv,qw,qx,qy,qz,r0,r1,r2,r3,r4,r5,r6,r7
r8,r9,ra,rb,rc,rd,re,rf,rg,rh,ri,rj,rk,rl,rm,rn
ro,rp,rq,rr,rs,rt,ru,rv,rw,rx,ry,rz,s0,s1,s2,s3
s4,s5,s6,s7,s8,s9,sa,sb,sc,sd,se,sf,sg,sh,si,sj
sk,sl,sm,sn,so,sp,sq,sr,ss,st,su,sv,sw,sx,sy,sz
t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc,td,te,tf
tg,th,ti,tj,tk,tl,tm,tn,to,tp,tq,tr,ts,tt,tu,tv
tw,tx,ty,tz,u0,u1,u2,u3,1a6,u5,u6,u7,u8,u9,ua,ub
uc,ud,ue,uf,ug,uh,ui,uj,uk,ul,um,un,uo,up,uq,ur
us,ut,uu,uv,uw,ux,uy,uz,v0,v1,v2,v3,v4,v5,v6,v7
v8,v9,va,vb,vc,vd,ve,vf,vg,vh,vi,vj,vk,vl,vm,vn
vo,vp,vq,vr,vs,vt,vu,vv,vw,vx,vy,vz,w0,w1,w2,w3
1a6,w5,w6,w7,w8,w9,wa,wb,wc,wd,we,wf,wg,wh,wi,wj
wk,wl,wm,wn,wo,wp,wq,wr,ws,wt,wu,wv,ww,wx,wy,1
1,wz,x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,1,xc
NAME Forest
EXT 8,8 b 7,15
PAL 9

ROOM b
14g,14h,14i,14j,14k,14l,14j,14k,14l,14j,14k,14l,14j,14m,14n,14o
14p,14q,14r,14s,14t,14u,14v,14w,14x,14y,14z,150,151,152,153,154
155,156,157,158,159,15a,15b,15c,15d,15e,15f,15g,15h,15i,15j,15k
15l,15m,15n,15o,15p,15q,15r,15s,15t,15u,15v,15w,15x,15y,15z,160
161,162,163,164,165,166,167,168,169,16a,16b,16c,16d,16e,16f,16g
16h,16i,16j,16k,16l,16m,16n,16o,16p,16q,16r,16s,16t,16u,16v,16w
16x,16y,16z,170,171,172,173,174,175,176,177,25,178,1,179,17a
17b,17c,17d,17e,17f,17g,17h,17i,17j,17k,17l,1,1,17m,17n,17o
17p,17q,17r,17s,17t,17u,17v,17w,1,1,yo,17x,17y,17z,180,181
182,183,184,185,186,187,1u,188,189,18a,18b,18c,18d,18e,18f,18g
18h,18i,18j,18k,18l,18m,18n,18o,18p,18q,1,18r,18s,18t,18u,1
18v,18w,18x,18y,1a6,190,191,192,193,194,1,195,196,197,198,1
1,1p,178,199,19a,19b,19c,1,1,19d,1,1,1,1,19e,19f
19g,19h,19i,19j,19k,19l,19m,1,1,1,1,1,1,19n,1,1
pu,192,19o,19p,19q,19r,19s,19t,19u,19v,19w,1,1,19x,1,1
1,1,1,19y,19z,1a0,1a1,1a6,1a3,1a4,1a5,1,1,1,1,1
NAME Forest2
EXT 4,11 7 8,15
PAL b

ROOM c
v,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,5y,5y,5y,5y,5y,5y,5y,5y,5y
1,1,1,1,1,1,1,5z,60,61,62,63,64,65,66,67
68,69,6a,6b,6c,6d,1,6e,6f,6g,6h,6i,6j,6k,6l,6m
u,6n,1,6o,6p,6q,6r,6s,6t,6u,6v,6w,6x,6y,6z,70
71,72,1,73,74,75,76,77,78,79,7a,7b,7c,7d,7e,7f
1,1,1,7g,7h,7i,7j,7k,7l,7m,7n,7o,7p,7q,7r,7s
7t,7u,7v,7w,7x,7y,7z,80,81,82,83,84,85,86,87,88
89,8a,8b,8c,8d,8e,8f,8g,8h,8i,8j,8k,8l,0,8n,8o
8p,8q,8r,8s,8t,8u,8v,8w,8x,0,8y,8z,90,0,91,92
93,94,95,96,97,98,99,9a,9b,9c,9d,9e,9f,9g,9h,9i
9j,9k,9l,9m,9n,9o,1,9p,9q,9r,9s,9t,9u,9v,9w,9x
1,1,9y,9z,a0,1,1,a1,1,a2,a3,a4,a5,a6,a7,a8
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
NAME Living Room2
ITM 4 7,11
ITM 0 10,10
ITM 3 3,9
PAL 4

TIL 1
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hallway (0,0)

TIL 2
11111110
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Hallway (0,7)

TIL 3
01100010
00100000
00011111
00000000
00000000
00000000
00000000
00000000
NAME Hallway (1,7)

TIL 4
00100010
00000000
00000000
00000000
00000000
00111111
00000000
00000000
NAME Hallway (2,7)

TIL 5
00101100
00010000
00100000
01000000
10000000
00000000
00000000
00000000
NAME Hallway (3,7)

TIL 6
01000100
01110011
10101011
11011010
10101011
01110011
00000011
01010011
NAME Hallway (4,7)

TIL 7
01000100
11111011
01011011
11111010
11111011
11111011
01111011
11111011
NAME Hallway (5,7)

TIL 8
01000100
11111000
11011000
11111000
11111000
11111000
01111000
11111000
NAME Hallway (6,7)

TIL 9
01000100
00000000
00000011
00000000
00000011
01110100
01010101
01010101
NAME Hallway (7,7)

TIL 10
11111100
11111100
11111100
11111100
11111111
11111111
11111111
11111111
NAME Hallway (0,10)

TIL 11
00000000
00000000
00000000
00000000
11111111
11111111
11111111
11111111
NAME Hallway (1,10)

TIL 12
00000000
00000000
00000000
00000000
11111100
11111110
11111111
11111111
NAME Hallway (2,10)

TIL 13
00000000
00000000
00011111
00100000
01001111
10010000
11111000
11111100
NAME Hallway (3,10)

TIL 14
10000000
00000000
11111110
00000001
11111100
00000010
00000111
00001111
NAME Hallway (4,10)

TIL 15
00000000
00000000
00000000
00000000
10001111
01011111
11111111
11111111
NAME Hallway (5,10)

TIL 16
00000101
00000101
00000101
00000101
11111101
11111111
11111111
11111111
NAME Hallway (14,10)

TIL 17
01011101
01011111
01010101
01010101
01010101
01010101
11010101
11110101
NAME Hallway (15,10)

TIL 18
11111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hallway (15,11)

TIL 19
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00000100
NAME Tree (6,0)

TIL 20
11111111
11111111
11111111
10111111
11101111
11110111
11011000
11111000
NAME Tree (6,3)

TIL 21
01101100
11101010
11111010
11111011
11100100
11110011
11111100
10110011
NAME Tree (7,3)

TIL 22
01111111
10111111
00111111
11001111
01110111
11010111
11111111
11111111
NAME Tree (8,3)

TIL 23
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110
NAME Tree (10,3)

TIL 24
11111111
11111111
11111111
11111111
10111111
11111111
11111111
01011111
NAME Tree (11,3)

TIL 25
10111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Tree (12,3)

TIL 26
10000000
10000000
01001100
11110000
11100000
11110101
11111100
11111111
NAME Tree (13,3)

TIL 27
00000000
00000000
00000000
00000000
00100000
01000000
10100000
11100000
NAME Tree (14,3)

TIL 28
00000010
00000111
00000001
00000011
00000010
00000111
00000101
00000001
NAME Tree (0,4)

TIL 29
00101100
01001100
01100011
11100000
01111111
01111111
00011011
11111011
NAME Tree (1,4)

TIL 30
11010001
01110111
11011101
01001111
10000110
00000100
00000000
00000001
NAME Tree (1,6)

TIL 31
01111010
00111010
11100000
01110000
11100000
10000000
11000000
10000000
NAME Tree (2,6)

TIL 32
11100000
00101000
00010000
00011000
00000000
00000000
00000000
00000000
NAME Tree (3,6)

TIL 33
01111111
00000111
00000101
00000110
00001001
00000000
00000000
00000000
NAME Tree (4,6)

TIL 34
10000011
11100010
11100001
00111111
00111111
00000000
00000000
00000000
NAME Tree (5,6)

TIL 35
11100010
11000000
10000000
11111100
11111100
01010000
00000010
00000101
NAME Tree (6,6)

TIL 36
01001111
00000011
00000011
00000001
00000000
00000001
00000010
00000100
NAME Tree (7,6)

TIL 37
01100000
11101000
11000000
11100000
11000000
11100011
11100001
11000011
NAME Tree (8,6)

TIL 38
00111111
01111111
11111101
10110001
01110001
01000101
11000011
11000110
NAME Tree (9,6)

TIL 39
11111111
11000000
00010000
11011111
01100010
10000000
00000000
00000000
NAME Tree (10,6)

TIL 40
00111011
10101011
00010000
00000000
00000000
00000000
00000000
00000000
NAME Tree (6,12)

TIL 41
11111111
10111111
00000010
00000000
00000000
00000000
00000000
00000000
NAME Tree (7,12)

TIL 42
11111110
11111111
11110000
00000000
00000000
00000000
00000000
00000000
NAME Tree (8,12)

TIL 43
10001011
10100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (9,12)

TIL 44
01010100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (10,12)

TIL 45
00100100
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (11,12)

TIL 46
00100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (12,12)

TIL 47
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000001
NAME Hallway2 (7,6)

TIL 48
00000000
00000000
00000000
01100000
11011000
11111110
10111110
11011111
NAME Hallway2 (8,6)

TIL 49
00000000
00000000
00000000
00000111
00000000
00000010
00000000
00000001
NAME Hallway2 (6,7)

TIL 50
11111111
11111111
11111111
11111111
01111111
01011111
00111111
00001111
NAME Hallway2 (9,10)

TIL 51
11011100
11011100
11111000
11111000
11110001
11101110
11111110
11011100
NAME Hallway2 (10,10)

TIL 52
00110000
00000000
00000000
00110000
11001000
00001000
00001000
00001000
NAME Hallway2 (11,10)

TIL 53
00000000
00000000
00000000
00000001
00000111
00011111
00011110
00111111
NAME Hallway2 (12,10)

TIL 54
00000000
00000000
00000000
11000100
11111110
11111111
10111111
11101111
NAME Hallway2 (13,10)

TIL 55
00000000
00000000
00100000
11110100
11111110
11111100
11111000
11111000
NAME Hallway2 (14,10)

TIL 56
01111111
01111111
00111111
00001111
00000111
00000000
00000000
00000000
NAME Hallway2 (1,11)

TIL 57
11111110
11111010
11111101
11111010
11110101
01110110
00111101
00011111
NAME Hallway2 (2,11)

TIL 58
10101010
10101101
01010101
11010111
01101110
10111010
01011110
01011111
NAME Hallway2 (3,11)

TIL 59
10010111
01111011
01101110
11011000
10100010
11111000
10101111
10100111
NAME Hallway2 (4,11)

TIL 60
10100000
00010000
10111111
00011010
01010100
10110010
11111010
01001001
NAME Living Room (8,3)

TIL 61
00000000
00000000
11100000
10010000
01010000
10010000
01010000
00110000
NAME Living Room (9,3)

TIL 62
00000000
00000000
00000000
00010010
00101010
10000000
10000000
10000000
NAME Living Room (10,3)

TIL 63
00000000
00000000
00000000
00000000
10000000
00000000
00000000
01000001
NAME Living Room (11,3)

TIL 64
00000000
00000000
00000000
00001001
00000001
00000001
00010001
00011111
NAME Living Room (12,3)

TIL 65
00000000
00000000
00011111
00100000
00110101
00100010
00101010
00100011
NAME Living Room (13,3)

TIL 66
00000000
00000000
11111111
00000000
00100100
10010000
11000101
11100000
NAME Living Room (14,3)

TIL 67
00000000
00000000
11111111
00000000
10010010
00000000
01010101
00000000
NAME Living Room (15,3)

TIL 68
11111111
11111111
11111111
11111111
11111110
11111100
11111100
11111100
NAME Living Room (0,4)

TIL 69
11111111
11111111
11111111
11111111
00000000
00000000
00000000
00111111
NAME Living Room (1,4)

TIL 70
11111111
11111111
11111111
00111111
01001111
11111111
11111111
11101010
NAME Living Room (15,5)

TIL 71
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111111
NAME Living Room (0,6)

TIL 72
00111111
00111111
00111111
00111111
00111111
00111111
00111111
11111111
NAME Living Room (1,6)

TIL 73
11100000
11100000
11100000
11100000
11100000
11100000
11100000
11111101
NAME Living Room (3,6)

TIL 74
00001011
00001111
00001011
00001110
00001011
00001111
00001011
10111011
NAME Living Room (4,6)

TIL 75
11111111
11111111
11010101
10110110
11111111
11111111
10101010
11111111
NAME Living Room (5,6)

TIL 76
11111111
11111111
01111111
10111111
11111111
11111111
11110001
01110001
NAME Living Room (6,6)

TIL 77
11101011
11000011
11111011
11111111
11111111
11011010
00000001
10101010
NAME Living Room (7,6)

TIL 78
11111111
11111111
11111111
10110111
00000111
01010111
00001111
00101111
NAME Living Room (8,6)

TIL 79
10110100
11111001
11111100
11111010
11110100
11000101
10000010
00000001
NAME Living Room (9,6)

TIL 80
11110101
11101001
11010110
00000101
01001000
01000001
10110001
10011001
NAME Living Room (7,8)

TIL 81
00000011
00000001
01000000
00000000
10000000
00000000
01000000
00000000
NAME Living Room (8,8)

TIL 82
11111110
11111101
10000000
00000000
00000011
00001111
00011111
00011101
NAME Living Room (9,8)

TIL 83
11111011
11011101
00000000
01010000
11000001
00000111
11000110
10000010
NAME Living Room (10,8)

TIL 84
11111111
01101011
00000000
00001010
01000000
11110000
01110000
10110001
NAME Living Room (11,8)

TIL 85
11101111
01011111
00000000
00000000
11100000
11111000
11111100
11111100
NAME Living Room (12,8)

TIL 86
11100000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Living Room (13,8)

TIL 87
11100010
01010101
11101101
11010010
10101010
11001001
11010101
11001010
NAME Living Room (14,8)

TIL 88
10101000
01010100
10111000
11010011
01110110
00011011
01011101
10100111
NAME Living Room (15,8)

TIL 89
11111110
11111110
11111110
11111111
11111110
11111110
11111111
11111110
NAME Living Room (0,9)

TIL 90
10100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Living Room (12,10)

TIL 91
11011111
01001001
01011111
01011111
00011111
01001111
01011000
01000100
NAME Living Room (14,10)

TIL 92
01101101
00000001
11111111
11111110
11111110
11111111
10001010
00100000
NAME Living Room (15,10)

TIL 93
11111110
11111111
11111110
11111110
11111110
11111111
11111110
11111111
NAME Living Room (0,11)

TIL 94
11010010
11011000
11111110
11111110
01111110
01111110
11111111
11111111
NAME Living Room (1,11)

TIL 95
10010101
01000000
10010100
10101011
00010000
10100100
11110010
11111001
NAME Living Room (2,11)

TIL 96
00101001
10000100
01010010
00100101
10010000
01001010
10010010
00100100
NAME Living Room (3,11)

TIL 97
00100001
01001000
00100101
01010010
10000100
00100010
10010001
01000100
NAME Living Room (4,11)

TIL 98
00010010
10101101
00011101
11001111
00101111
01000111
00011111
10101111
NAME Living Room (5,11)

TIL 99
00100010
10001001
11100100
11010010
11001001
11100100
11111111
11111111
NAME Living Room (6,11)

TIL 100
01111110
11110111
11111010
11111111
11110101
01111110
10111111
11011111
NAME Cat (15,5)

TIL 101
01011001
11101101
10111100
11111100
10111100
11101100
00000101
00000001
NAME Cat (0,6)

TIL 102
11000111
00001011
00011111
00011111
00011111
01101011
10010001
01001011
NAME Cat (1,6)

TIL 103
11011011
11110110
11011111
11101011
10111111
11011111
11111111
11011101
NAME Cat (2,6)

TIL 104
11111111
11101111
11111111
11111101
11110111
11111111
11111111
11111111
NAME Cat (3,6)

TIL 105
11111111
11011111
11111111
01111101
11111111
10110111
01111111
10101110
NAME Cat (4,6)

TIL 106
11111101
11111101
11111110
11111111
11110111
01001000
00000000
00000000
NAME Cat (5,6)

TIL 107
01110100
00111010
11111101
01111110
11111111
01110111
00111111
11110111
NAME Cat (6,6)

TIL 108
11111111
01111000
01110010
11100101
11101011
11101100
11111010
01011000
NAME Cat (7,6)

TIL 109
10010100
11011110
10101010
10101110
10010111
11110011
11101011
11101010
NAME Cat (8,6)

TIL 110
01000010
11000010
11100011
11110111
11110111
01011111
01111111
10011111
NAME Cat (4,8)

TIL 111
11100111
01010111
11110010
11111111
11111111
11111111
11011000
01110000
NAME Cat (5,8)

TIL 112
11000111
00000101
10000111
11011101
11111101
11111111
01111111
00100111
NAME Cat (6,8)

TIL 113
01110100
11111000
11110000
01110001
11110111
11111111
11111111
01011111
NAME Cat (7,8)

TIL 114
11111110
11101111
11110101
11011111
11110110
11111111
10011111
01101111
NAME Cat (8,8)

TIL 115
11000001
01000001
11100001
11010001
01101001
00011011
00011111
11001111
NAME Cat (9,8)

TIL 116
00111110
01111111
11111111
11111011
11111111
11110110
10000111
01010010
NAME Cat (10,8)

TIL 117
11100000
11000000
11001001
11110001
10100000
11110011
10100111
11111111
NAME Cat (11,8)

TIL 118
11111111
00111110
00011110
00011110
10011110
11111111
11101111
01111111
NAME Cat (12,8)

TIL 119
01011110
10100011
10011010
10110100
10111010
01111101
11111110
11101110
NAME Cat (13,8)

TIL 120
11111111
11111111
11111111
11111111
11111111
11111110
11111110
11111111
NAME Cat (8,10)

TIL 121
11111100
11111100
11111110
11111100
11111000
00010000
01001110
00000100
NAME Cat (9,10)

TIL 122
00011010
00001110
00011110
00001110
00000110
00000100
10100011
00000111
NAME Cat (10,10)

TIL 123
00000001
00000001
00000010
00010011
00011110
01111111
01111101
11111011
NAME Cat (11,10)

TIL 124
01111010
01111100
10011011
10101010
11110101
01111100
10111010
11101001
NAME Cat (12,10)

TIL 125
10111010
11111101
11011111
01000110
00101011
11000010
01101011
11110011
NAME Cat (13,10)

TIL 126
11111110
10110110
01111110
11111011
11111101
11101110
11110101
11111111
NAME Cat (14,10)

TIL 127
10100010
10111101
11110110
11111011
11000100
10010010
00100110
01001111
NAME Cat (15,10)

TIL 128
01010110
10111011
11010111
01111101
10101101
10000001
00101011
00010111
NAME Cat (0,11)

TIL 129
11101111
10111111
11110111
01011111
11111011
01101111
11111111
11011011
NAME Cat (1,11)

TIL 130
11011111
01011111
10101101
01010111
01011011
11111111
11011101
11110111
NAME Cat (12,12)

TIL 131
11000010
11010101
11110001
11101111
01110000
11100101
10100100
11010011
NAME Cat (13,12)

TIL 132
10010111
01101011
10010100
11101010
00011111
01001111
10010111
10100011
NAME Cat (14,12)

TIL 133
11111110
11111011
11011111
11111111
11101111
01111111
11110011
11010101
NAME Cat (15,12)

TIL 134
11001011
01110011
01111011
01111111
01111111
11111110
10100101
00010010
NAME Cat (0,13)

TIL 135
11111001
11111100
11101010
01111000
11111010
00000111
00000100
00001010
NAME Cat (1,13)

TIL 136
01111111
00111101
10111111
00111110
10110001
11100100
00110000
01101010
NAME Cat (2,13)

TIL 137
01101101
11111100
10111101
11110101
11111101
00111101
10011110
00001111
NAME Cat (3,13)

TIL 138
11101101
11111111
01101101
00111111
01011110
01011011
10101110
10110010
NAME Cat (4,13)

TIL 139
11101010
01111111
11101100
10111010
11111001
11111010
11011100
01111110
NAME Cat (5,13)

TIL 140
10100010
01111000
01011011
01011100
10111010
01010000
01010101
10110111
NAME Cat (0,15)

TIL 141
00110111
10011010
11101111
00111010
10111111
01111101
11111110
11111011
NAME Cat (1,15)

TIL 142
11111111
11111101
10100111
11010110
01100011
10101001
11100101
01010001
NAME Cat (2,15)

TIL 143
11010111
01111011
10101101
11111111
01111111
10111111
11010111
01111101
NAME Cat (3,15)

TIL 144
11101011
11110111
11111111
11111111
11111101
11101111
10111111
11110111
NAME Cat (4,15)

TIL 145
11111111
10111100
11111101
01110110
11111111
11111011
11011111
01000010
NAME Cat (5,15)

TIL 146
10111111
11111011
00001111
11101011
00101011
11010100
11111111
10111111
NAME Cat (6,15)

TIL 147
11111111
11111110
11111111
11111011
11111111
11111110
11111111
11111111
NAME Cat (7,15)

TIL 148
11111101
11111100
11111111
11011111
10000001
00100111
01011001
11101011
NAME Cat (8,15)

TIL 149
00001111
11010001
11101011
11010110
10101011
10100110
10101110
10111110
NAME Cat (9,15)

TIL 150
01010010
01010101
01010101
10101010
01010101
01001010
01010100
01010101
NAME Forest2 (11,1)

TIL 151
01010101
01010101
01010101
10101010
01010101
10010010
10101010
01010101
NAME Forest2 (12,1)

TIL 152
01001010
01010101
01010101
10101010
01010101
01001001
10101010
01010101
NAME Forest2 (13,1)

TIL 153
10100101
01010101
01010101
10101010
00101001
01010101
10101010
01010101
NAME Forest2 (14,1)

TIL 154
01010101
01010100
01010101
10101010
01010101
00101010
10100100
01010101
NAME Forest2 (15,1)

TIL 155
01010101
01010101
01001010
00101010
01010101
01010100
01010011
01010101
NAME Forest2 (0,2)

TIL 156
00101010
01010100
10101010
10100101
01010101
01010101
01010101
01010100
NAME Forest2 (1,2)

TIL 157
10101010
10101010
10101010
01010101
01001010
01010100
00101010
11010101
NAME Forest2 (2,2)

TIL 158
10101010
10101010
10010101
01010101
10101010
10100101
10010100
01010101
NAME Forest2 (3,2)

TIL 159
10101010
01010101
01010010
01001010
10101010
01010101
10101010
01010101
NAME Forest2 (4,2)

TIL 160
01010101
10101010
10010100
01010010
00010101
10101010
01010101
01010100
NAME Forest2 (15,3)

TIL 161
01010101
01010101
01010101
01001010
00101010
01010101
01010100
01010101
NAME Forest2 (0,4)

TIL 162
01001010
00101010
01010101
10101010
10101010
01010101
10101001
01010101
NAME Forest2 (1,4)

TIL 163
10010101
01010101
01010101
10101010
10101001
01010101
00101010
01010101
NAME Forest2 (2,4)

TIL 164
01010101
01010101
01010101
10101010
01010100
00100101
10101010
01010101
NAME Forest2 (3,4)

TIL 165
01010101
01010101
01010010
10101010
01001010
01010101
10100010
01011000
NAME Forest2 (4,4)

TIL 166
00101010
01000101
10110111
10010101
10111110
01010111
10101101
10101110
NAME Forest2 (5,4)

TIL 167
10110111
11011101
01110111
11011101
11110111
10111101
11010111
11111101
NAME Forest2 (6,4)

TIL 168
11101010
01111111
10101010
11111111
01010101
11111111
01101010
11011111
NAME Forest2 (7,4)

TIL 169
10111111
11101101
10110111
11111110
01010111
11111110
10101111
11111101
NAME Forest2 (8,4)

TIL 170
00101010
00101010
10101010
01001001
00100100
01010101
10101010
01001001
NAME Forest2 (3,6)

TIL 171
10101001
10100101
10010101
01010100
00100010
10101010
01010101
01010101
NAME Forest2 (4,6)

TIL 172
01111111
00101011
01011110
10110111
01011101
10110111
01111101
01101110
NAME Forest2 (5,6)

TIL 173
01111010
11011111
11101010
01111111
11010101
01111111
11010111
11111111
NAME Forest2 (6,6)

TIL 174
10101111
11111101
10111111
11110101
11101111
01111010
11011111
01101011
NAME Forest2 (7,6)

TIL 175
11111111
11111111
11111101
01111111
11010101
11111111
01010101
11111110
NAME Forest2 (8,6)

TIL 176
11101011
01111110
11010111
01111010
11011111
01101010
10111111
11101010
NAME Forest2 (9,6)

TIL 177
01111111
11111111
11111111
11111111
10111111
11111111
01011111
11111111
NAME Forest2 (10,6)

TIL 178
11101111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Forest2 (12,6)

TIL 179
11010100
11101010
11110101
11111010
11111001
11110101
11111010
11110101
NAME Forest2 (14,6)

TIL 180
00010001
01000100
00010001
10000100
00100001
01001000
10000101
00100000
NAME Forest2 (14,8)

TIL 181
00000100
00100011
00001001
01000010
00010101
01000101
00010110
01001011
NAME Forest2 (15,8)

TIL 182
10100000
11010101
01000000
11010101
01000000
10000000
01100000
11010000
NAME Forest2 (0,9)

TIL 183
01000010
00010000
01000100
00010001
00100100
00000011
00000101
00000010
NAME Forest2 (1,9)

TIL 184
00010000
10100111
10110101
01011110
10101010
01110111
10101010
11101101
NAME Forest2 (2,9)

TIL 185
00010000
01000100
10010001
10000100
11110001
01011000
11010000
01100000
NAME Forest2 (3,9)

TIL 186
10000010
00100100
00010000
01000000
00010000
00000000
00010000
00000000
NAME Forest2 (4,9)

TIL 187
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Forest2 (5,9)

TIL 188
00000010
00000100
00000000
00000001
00000000
00000000
00000000
10000000
NAME Forest2 (7,9)

TIL 189
11111111
11011111
11111110
01111111
00011111
10000111
00100011
01001001
NAME Forest2 (8,9)

TIL 190
11010101
01110111
11011111
01110111
11011110
10110111
11111011
01011111
NAME Forest2 (5,11)

TIL 191
11111111
10111011
01111110
11111111
11111111
11111111
11111111
11111111
NAME Forest2 (6,11)

TIL 192
10111101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Forest2 (7,11)

TIL 193
01111100
11111100
11111101
11111101
11111101
11111011
11111101
11111111
NAME Forest2 (8,11)

TIL 194
00001111
00101111
11101111
01111111
11010111
10111111
11101111
01111111
NAME Forest2 (9,11)

TIL 195
10101011
10100100
11011010
11110101
11110111
11111101
11111111
11111111
NAME Forest2 (11,11)

TIL 196
10111101
11011111
01010101
10101111
11110111
11111111
11111111
11111111
NAME Forest2 (12,11)

TIL 197
10111101
01010010
11010101
11101011
11111111
11111111
11111111
11111111
NAME Forest2 (13,11)

TIL 198
00011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Forest2 (14,11)

TIL 199
11101011
01111110
11010111
11111101
11110111
11111101
11111111
11111111
NAME Forest2 (3,12)

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME block

TIL b
01000100
00000000
11110000
00000000
11110000
00101000
10101000
01001000
NAME Hallway (8,7)

TIL c
01000100
00000000
00000011
00000000
00000111
00001000
00000111
00000100
NAME Hallway (9,7)

TIL d
01000100
00000000
11111111
00000000
11111111
00000000
11111111
00000000
NAME Hallway (10,7)

TIL e
01000100
00000000
11100000
00010000
11110000
00010000
11110000
00010000
NAME Hallway (11,7)

TIL f
01000100
00000000
00000000
00000000
00000000
00000001
00000010
00000010
NAME Hallway (12,7)

TIL g
11000100
10000000
10000000
10000000
10000000
00000100
00001001
00000100
NAME Hallway (13,7)

TIL h
01000111
00000000
00000000
00000000
00000000
10010000
00100000
10010000
NAME Hallway (14,7)

TIL i
11111111
11111111
00111111
00001111
00000011
00000000
00000000
00000000
NAME Hallway (15,7)

TIL j
11111100
11111100
11111100
11111111
11111110
11111111
11111110
11111100
NAME Hallway (0,8)

TIL k
00000000
00000000
00000000
11111111
00000000
11111111
00000000
00000000
NAME Hallway (1,8)

TIL l
01110101
00000101
00000101
11111100
00000111
11111000
00000000
00000000
NAME Hallway (7,8)

TIL m
01011000
01001000
10101000
00101111
11111000
00000111
00000000
00000000
NAME Hallway (8,8)

TIL n
00000000
00000111
00000000
11111111
00000000
11111111
00000000
00000000
NAME Hallway (9,8)

TIL o
01111110
11111111
00000000
11111111
00000000
11111111
00000000
00000000
NAME Hallway (10,8)

TIL p
00010000
11100000
00000000
11111111
00000000
11111111
00000000
00000000
NAME Hallway (11,8)

TIL q
00000001
00000000
00000000
11111111
00000000
11111111
00000000
00000000
NAME Hallway (12,8)

TIL r
00000000
10000000
10000000
11111111
10000000
11111111
00000000
00000000
NAME Hallway (13,8)

TIL s
00000000
00000000
00000000
11111100
00000011
11111100
00000111
00000101
NAME Hallway (14,8)

TIL t
00000000
00000000
00000000
00000000
00000000
11000000
00110000
11001100
NAME Hallway (15,8)

TIL u
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Hallway (0,9)

TIL w
00000000
00000000
00000000
00000000
00101111
00000000
10000000
10000000
NAME Hallway (4,9)

TIL x
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000
NAME Hallway (5,9)

TIL y
00000101
00000101
00000101
00000101
11111101
00000111
00000101
00000101
NAME Hallway (14,9)

TIL z
01110011
01011100
01010111
01010101
01010101
01010101
11010101
11110101
NAME Hallway (15,9)

TIL 1a
00000000
00000000
00000000
00000000
00000000
00000000
00010000
00100000
NAME Tree (7,0)

TIL 1b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME Tree (8,0)

TIL 1c
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000100
NAME Tree (4,1)

TIL 1d
00000000
00010001
01000110
00010010
00110100
10011001
10111100
11011010
NAME Tree (5,1)

TIL 1e
00110010
10000110
01000001
10100101
00000101
01110000
10011010
01101010
NAME Tree (6,1)

TIL 1f
11101010
10111001
00100111
01101010
01001011
10001010
10100111
10010101
NAME Tree (7,1)

TIL 1g
10000001
00010000
11100101
11011100
11100101
11111110
11110111
11111111
NAME Tree (8,1)

TIL 1h
00000000
01000000
01101000
11101000
10111000
00111110
11101110
11111111
NAME Tree (9,1)

TIL 1i
00000000
00000000
00000000
00000000
00000000
10000000
11000000
11000100
NAME Tree (10,1)

TIL 1j
00000000
00000000
00000010
00000000
00000101
00000010
00000111
00000011
NAME Tree (3,2)

TIL 1k
00001010
00101111
00010110
01001010
01100000
11101001
10100010
10111001
NAME Tree (4,2)

TIL 1l
10100101
00011001
10100101
00000110
01010001
00000110
01101011
00101101
NAME Tree (5,2)

TIL 1m
10111010
01111111
11111111
11111111
11111111
11011111
11111111
11111111
NAME Tree (6,2)

TIL 1n
10101111
01001010
10000100
10101001
11100100
11011001
01110100
11110001
NAME Tree (7,2)

TIL 1o
10111111
01111111
01111111
01011111
10110111
01101011
10110111
01111011
NAME Tree (8,2)

TIL 1p
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Tree (9,2)

TIL 1q
11011000
11110010
11111110
11111011
11101110
11111111
11111111
11111111
NAME Tree (10,2)

TIL 1r
00000000
00110000
00100000
11010000
00100000
11110100
11110001
11101111
NAME Tree (11,2)

TIL 1s
00000000
00000000
00000000
00100110
00010010
00100110
10011110
10111110
NAME Tree (12,2)

TIL 1t
00000000
00000000
00000000
00000000
00000000
00000000
00100000
01000000
NAME Tree (13,2)

TIL 1u
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME Tree (0,3)

TIL 1v
00000000
00000000
00000000
00000000
00000011
10001000
01010010
01101010
NAME Tree (1,3)

TIL 1w
00000000
00001000
00001000
00111111
01011111
11101011
00100101
10111011
NAME Tree (2,3)

TIL 1x
00000001
00000010
00000110
11100010
01111010
11111101
11111111
11111111
NAME Tree (3,3)

TIL 1y
11110111
11111011
10101001
10111111
11111110
11111111
11101111
11001111
NAME Tree (4,3)

TIL 1z
11101011
11101011
11111111
11111110
11111110
11111111
11111111
11011111
NAME Tree (5,3)

TIL 2a
00110111
10110111
01000011
01000101
11111011
11111111
11111111
11111111
NAME Tree (2,4)

TIL 2b
11111111
11111111
11111101
11101011
11000001
11010110
11100101
11011111
NAME Tree (3,4)

TIL 2c
11111101
11111111
11111111
11111111
11111111
11111001
10111101
00011011
NAME Tree (6,4)

TIL 2d
01100111
10011011
10101011
11111111
11101011
11111111
11111111
11111111
NAME Tree (7,4)

TIL 2e
11111111
11111101
11111111
11111111
11111111
11111111
11111111
11111111
NAME Tree (8,4)

TIL 2f
11111111
11111111
11111110
11111111
11111111
11111111
11111111
11111111
NAME Tree (10,4)

TIL 2g
00101111
10111111
10001111
01111111
01111011
10111110
11111111
11111111
NAME Tree (11,4)

TIL 2h
11111010
11110101
11110111
11111111
11111111
11111111
11111111
11111111
NAME Tree (13,4)

TIL 2i
11000000
11100000
11111010
11111000
11111000
11111100
11111100
11111100
NAME Tree (14,4)

TIL 2j
00000010
00001011
00010111
00000001
00000111
00000010
00000000
00000001
NAME Tree (0,5)

TIL 2k
11110111
11011111
01111101
11101111
10111111
01110111
00111111
11011100
NAME Tree (1,5)

TIL 2l
11111111
11111111
11111111
11111111
11111111
01111111
01111111
00011111
NAME Tree (2,5)

TIL 2m
11111111
11111111
11111111
11111111
11110100
11111000
11111111
11110011
NAME Tree (3,5)

TIL 2n
11111111
11111111
11111111
11111111
01111111
00111111
00111111
11111110
NAME Tree (4,5)

TIL 2o
11111111
11110001
11110000
11010110
10111011
11101110
11010110
00000111
NAME Tree (5,5)

TIL 2p
11101111
10111011
00111111
00011111
00001111
01110111
11000101
01000000
NAME Tree (6,5)

TIL 2q
11111111
11111111
11111111
11111111
11111111
11111111
01111111
10011110
NAME Tree (7,5)

TIL 2r
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111100
NAME Tree (8,5)

TIL 2s
11111111
11111111
11111111
11111111
11111110
01111110
01110100
00011111
NAME Tree (9,5)

TIL 2t
11111111
11111111
11111111
01111111
01001111
00000111
00101111
11111111
NAME Tree (10,5)

TIL 2u
11111111
11111111
11111111
11111111
11111111
11111111
11000101
10000000
NAME Tree (11,5)

TIL 2v
11111111
11111111
11111111
11111111
11101111
00001111
00000111
00100110
NAME Tree (12,5)

TIL 2w
11111111
11111111
11111111
11111111
11111111
11111111
01110111
01111011
NAME Tree (13,5)

TIL 2x
11111100
11111000
11111110
11111111
11111111
11111101
11111111
11011001
NAME Tree (14,5)

TIL 2y
00000000
00000000
01000000
00000000
01000000
10110100
11011000
00000000
NAME Tree (15,5)

TIL 2z
00000000
00000010
00000100
00000000
00000000
00000000
00000000
00000000
NAME Tree (0,6)

TIL 3a
10001000
00000000
01010000
00000000
00000000
00000000
00000000
00000000
NAME Tree (11,6)

TIL 3b
00000001
00000100
00000000
00000100
00000000
00000000
00000000
00000000
NAME Tree (12,6)

TIL 3c
10010110
00010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (13,6)

TIL 3d
01111100
00011111
01001010
00101110
01101001
00001000
00000000
00000000
NAME Tree (14,6)

TIL 3e
00000000
10000000
01110000
11000000
10000000
00000000
00000000
00000000
NAME Tree (15,6)

TIL 3f
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (1,7)

TIL 3g
00000011
00000000
00000001
00000000
00000001
00000110
00000100
00001000
NAME Tree (6,7)

TIL 3h
10001000
11111000
01110000
11110010
11000011
00001111
00101111
10111110
NAME Tree (7,7)

TIL 3i
00000000
00001100
01111111
11111111
11111010
11000000
10000000
00000000
NAME Tree (8,7)

TIL 3j
10011100
00101100
11000100
11111100
10100000
00000000
00000000
00000000
NAME Tree (9,7)

TIL 3k
00010000
00010100
00101001
00010001
01000011
01100011
01100011
01000011
NAME Tree (6,8)

TIL 3l
11111000
11110000
11100000
11000000
11000000
10000000
10000000
00000000
NAME Tree (7,8)

TIL 3m
11000111
11000011
11000111
11000110
01010111
11001111
01000111
11001111
NAME Tree (6,9)

TIL 3n
01000111
11100111
11100111
00111111
11010111
00101111
01011011
00001011
NAME Tree (6,10)

TIL 3o
10000000
10000000
10000000
10000000
11000000
11000000
11100000
11110000
NAME Tree (7,10)

TIL 3p
00000000
00000000
00000000
00000010
00000000
00000000
00000000
00000000
NAME Tree (5,11)

TIL 3q
00111111
01101101
00111111
00101111
00011111
00001110
00011111
01001111
NAME Tree (6,11)

TIL 3r
11111000
11111100
11111111
01111111
01111111
10111111
01111111
11111111
NAME Tree (7,11)

TIL 3s
00000000
00000000
00000000
00000000
10000000
11000000
11100001
11100000
NAME Tree (8,11)

TIL 3t
00000000
00000000
00000000
00000000
00000000
00000000
00000010
10010000
NAME Tree (9,11)

TIL 3u
00000000
00000000
00000000
00000000
00000000
00000100
00100000
10000101
NAME Tree (10,11)

TIL 3v
00000000
00000000
00000000
00000000
00000000
00000000
01001010
00011010
NAME Tree (11,11)

TIL 3w
00000000
00000000
00000000
00000000
00000000
00001000
10000010
00101101
NAME Tree (12,11)

TIL 3x
00000000
00000000
00000000
00000000
00100000
10001001
00101000
00001010
NAME Tree (13,11)

TIL 3y
00000000
00000000
00000000
00000000
00000000
00001000
01010000
00000000
NAME Tree (14,11)

TIL 3z
00000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Tree (5,12)

TIL 4a
00000001
11000001
11011001
11111001
00111001
00011001
00110001
11000001
NAME Hallway2 (7,7)

TIL 4b
11111111
10111111
11011111
11111111
10111111
11011111
11111111
10111111
NAME Hallway2 (8,7)

TIL 4c
11110000
11111100
11111100
11111100
11111100
11111100
11111100
11111100
NAME Hallway2 (9,7)

TIL 4d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00011000
NAME Hallway2 (12,7)

TIL 4e
11000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME Hallway2 (7,8)

TIL 4f
11011111
11111111
10111111
11011111
11111111
10111111
11011111
11111111
NAME Hallway2 (8,8)

TIL 4g
00000000
00000011
00001111
00111111
00111111
00111111
00111111
00111111
NAME Hallway2 (11,8)

TIL 4h
11111000
11111000
11111000
11111000
11111000
11111000
11111000
11111000
NAME Hallway2 (12,8)

TIL 4i
00000000
00000000
00000000
00000011
00011000
01101000
01001000
01001000
NAME Hallway2 (1,9)

TIL 4j
00001111
00110001
11010001
10010001
10010001
10010001
10010011
10010001
NAME Hallway2 (2,9)

TIL 4k
00111000
00100111
00100100
00100100
00100100
00100100
00100100
00100100
NAME Hallway2 (3,9)

TIL 4l
00000000
10000000
01110000
01000000
01000000
01000000
01000000
01000000
NAME Hallway2 (4,9)

TIL 4m
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME Hallway2 (7,9)

TIL 4n
10111111
11011111
11111111
10111111
11011111
11111111
10111111
11011111
NAME Hallway2 (8,9)

TIL 4o
11111100
11111100
11111100
11111100
11111101
11111111
11111111
11111111
NAME Hallway2 (9,9)

TIL 4p
00000000
00000000
00000000
00000000
00000000
11000000
11000000
11001000
NAME Hallway2 (10,9)

TIL 4q
00111111
00111111
00111101
00111111
00111111
00111111
00111111
00111100
NAME Hallway2 (11,9)

TIL 4r
11111000
11111100
11111000
11111000
11110000
10000000
00000000
00000000
NAME Hallway2 (12,9)

TIL 4s
01001000
01001000
01001000
01011111
01111111
01111111
01111111
01111111
NAME Hallway2 (1,10)

TIL 4t
10111001
11111111
10111011
11000011
11100111
11111111
11111110
11111101
NAME Hallway2 (2,10)

TIL 4u
00100100
11100100
11110111
10111111
11010111
01011010
10101011
10110101
NAME Hallway2 (3,10)

TIL 4v
01000000
01000000
11000000
11100000
11110000
11110000
01110000
10110000
NAME Hallway2 (4,10)

TIL 4w
00000000
00000000
00000000
00000000
00001100
00111011
01111111
11101100
NAME Hallway2 (5,10)

TIL 4x
00000000
00000000
00000000
00011000
01100111
10111000
10000000
01100000
NAME Hallway2 (6,10)

TIL 4y
00000001
00000001
00110001
11001101
00000011
00000000
00000000
00000000
NAME Hallway2 (7,10)

TIL 4z
11111111
10111111
11101111
10010101
10000001
01000000
00000001
00011000
NAME Hallway2 (8,10)

TIL 5a
11110011
10001000
00100000
01000000
01110000
01001100
11000111
01000011
NAME Hallway2 (5,11)

TIL 5b
10000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME Hallway2 (6,11)

TIL 5c
00001111
10000111
00110101
00000111
00000111
00000111
00000111
00000011
NAME Hallway2 (9,11)

TIL 5d
11111110
11110101
11100011
11110111
11111010
11111111
11111011
10110001
NAME Hallway2 (10,11)

TIL 5e
00111000
11101110
01111001
11000000
00000000
00000001
11000111
11101110
NAME Hallway2 (11,11)

TIL 5f
00111101
00111111
11010111
00101011
01110001
11100111
11001111
11101111
NAME Hallway2 (12,11)

TIL 5g
01111111
11111111
11110011
11001111
11010111
11111011
11111111
11111001
NAME Hallway2 (13,11)

TIL 5h
11111110
11111000
11111100
11111000
11111000
11111000
11111000
11111000
NAME Hallway2 (14,11)

TIL 5i
00000111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (2,12)

TIL 5j
10110011
11110000
00110000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (3,12)

TIL 5k
11100001
01100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (4,12)

TIL 5l
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (5,12)

TIL 5m
01100000
00011000
00000110
00000001
00000000
00000000
00000000
00000000
NAME Hallway2 (6,12)

TIL 5n
00000000
00000000
00000000
11000000
00110000
00001100
00000011
00000011
NAME Hallway2 (7,12)

TIL 5o
00000000
00000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME Hallway2 (8,12)

TIL 5p
00000011
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (9,12)

TIL 5q
11110101
11101001
00000001
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (10,12)

TIL 5r
10111010
10111000
10010000
00010000
00000000
00000000
00000000
00000000
NAME Hallway2 (11,12)

TIL 5s
11010111
11000001
00000000
00000000
00000000
00000000
00000001
00000001
NAME Hallway2 (12,12)

TIL 5t
11111010
11100000
10000000
00000011
00001100
00110000
11000000
10000000
NAME Hallway2 (13,12)

TIL 5u
11110100
01011000
11100000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (14,12)

TIL 5v
00000000
00000000
00000000
11000000
00111111
00000000
00000000
00000000
NAME Hallway2 (9,13)

TIL 5w
00000000
00000000
00000000
00000011
11111100
00000000
00000000
00000000
NAME Hallway2 (11,13)

TIL 5x
00000110
00011000
11100000
00000000
00000000
00000000
00000000
00000000
NAME Hallway2 (12,13)

TIL v
11111111
11111111
11111111
10011111
10011001
10011011
11111111
11111111
NAME Living Room (0,0)

TIL 5y
11111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME Living Room (7,2)

TIL 5z
00000010
00001001
00011100
00111101
00111101
00111110
00101111
00110010
NAME Living Room (7,3)

TIL 6a
11111111
11111111
11111111
11111111
00000000
00000000
00000000
11111111
NAME Living Room (2,4)

TIL 6b
11111111
11111111
11111111
11111111
00000000
00000000
00000000
11100000
NAME Living Room (3,4)

TIL 6c
11111111
11111111
11111111
11111111
00001111
00001011
00001111
00001011
NAME Living Room (4,4)

TIL 6d
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011011
NAME Living Room (5,4)

TIL 6e
00100000
00111111
00111111
00111110
00111101
00111111
11111111
11111111
NAME Living Room (7,4)

TIL 6f
00000000
11111111
11111111
11111111
11000110
10111111
11111111
11111111
NAME Living Room (8,4)

TIL 6g
00010000
11110000
11110000
11110000
11110000
01110000
11111010
11111111
NAME Living Room (9,4)

TIL 6h
10000000
10000010
11111111
00000000
00000000
00000000
10101010
11111111
NAME Living Room (10,4)

TIL 6i
01000110
11000000
11000100
00000110
00000011
00000000
10101010
11111111
NAME Living Room (11,4)

TIL 6j
11000000
00001000
01001000
11000010
10000000
00000000
10101010
11111111
NAME Living Room (12,4)

TIL 6k
00110000
01011111
01111111
10111111
00011111
00111111
10111000
11111111
NAME Living Room (13,4)

TIL 6l
00001001
11111111
11111111
11111111
11111111
11011111
00011111
11111111
NAME Living Room (14,4)

TIL 6m
00100100
11111111
11111111
11111111
11111111
11111110
10001000
11111111
NAME Living Room (15,4)

TIL 6n
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME Living Room (1,5)

TIL 6o
11100000
11100000
11100000
11100000
11100000
11100000
11100000
11100000
NAME Living Room (3,5)

TIL 6p
00001111
00001011
00001111
00001010
00001011
00001111
00001011
00001110
NAME Living Room (4,5)

TIL 6q
11111111
11111111
10101101
11010101
11111111
11111111
11011011
01010101
NAME Living Room (5,5)

TIL 6r
11111111
11111111
01111111
10111111
11111111
11111111
01111111
01111111
NAME Living Room (6,5)

TIL 6s
11111010
11111111
11111111
11111111
11111110
11111111
11111111
11111111
NAME Living Room (7,5)

TIL 6t
11111111
11111111
11100111
11110101
10100100
11111111
11111111
11111111
NAME Living Room (8,5)

TIL 6u
11111111
11111111
11111111
11111111
11111111
11111000
11001000
11100100
NAME Living Room (9,5)

TIL 6v
11111111
11111111
11111111
11111111
11111111
11010001
00100000
10110001
NAME Living Room (10,5)

TIL 6w
11111111
11111111
11111111
11111111
11111111
11100110
00000001
11000101
NAME Living Room (11,5)

TIL 6x
11111111
11111111
11111111
11111111
11111111
10001111
00000011
01001010
NAME Living Room (12,5)

TIL 6y
11111111
11111110
11111101
11111111
11111100
11111111
11111111
11111110
NAME Living Room (13,5)

TIL 6z
11111111
11111111
00111010
10110000
10100000
11111111
11111111
10111111
NAME Living Room (14,5)

TIL 7a
01000001
11110101
10110010
11101001
10110011
01110001
11101011
11111111
NAME Living Room (10,6)

TIL 7b
00100010
11101011
10100111
11101110
01111111
10111011
11101011
11110001
NAME Living Room (11,6)

TIL 7c
10001011
01001111
10101011
11001111
10011011
11000001
01100000
11000000
NAME Living Room (12,6)

TIL 7d
01111111
11111010
11111111
11111010
11110001
11111000
11110010
11010000
NAME Living Room (13,6)

TIL 7e
11010111
11101101
11111111
00001001
01000000
00010100
10101001
00010010
NAME Living Room (14,6)

TIL 7f
10111111
11010101
11111111
00101010
10000000
01010101
00000001
10101000
NAME Living Room (15,6)

TIL 7g
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101000
NAME Living Room (3,7)

TIL 7h
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME Living Room (4,7)

TIL 7i
11111111
11011011
01101101
11111111
11110111
10101101
10110110
11111111
NAME Living Room (5,7)

TIL 7j
11110001
11110001
01010001
11110001
01110001
11010001
11110001
11110001
NAME Living Room (6,7)

TIL 7k
01000010
10010100
01001010
01010000
10001010
01010100
11111010
11110000
NAME Living Room (7,7)

TIL 7l
00001101
10101110
00000111
10001101
01001110
10001111
10001111
01000111
NAME Living Room (8,7)

TIL 7m
10000010
11000000
11111000
11101100
10101000
11010000
11111101
11110100
NAME Living Room (9,7)

TIL 7n
11100000
00110001
10100001
10100000
01010001
01000000
11110011
10110101
NAME Living Room (10,7)

TIL 7o
11110011
00110011
10100011
10110001
01010010
10100001
01111111
11011111
NAME Living Room (11,7)

TIL 7p
11000000
00010001
10001111
00000111
10001011
00000101
11011111
01001011
NAME Living Room (12,7)

TIL 7q
11110000
11011010
11110000
11010000
10110000
11110000
11110000
11110000
NAME Living Room (13,7)

TIL 7r
00010000
11010101
01010000
01010101
01010001
01001000
01111111
01011101
NAME Living Room (14,7)

TIL 7s
00101011
10001100
01010100
00011000
01001000
11111000
11110000
01010000
NAME Living Room (15,7)

TIL 7t
11111111
11111111
11111111
11111111
11111110
11111111
11111111
11111110
NAME Living Room (0,8)

TIL 7u
11111000
10110010
11111001
11110100
00010001
11101010
01010000
00000101
NAME Living Room (1,8)

TIL 7v
00000000
01001010
00100001
10010100
00100010
10010100
01000010
00010001
NAME Living Room (2,8)

TIL 7w
00000010
01010100
00000010
10101001
00100100
10010010
01001001
00100010
NAME Living Room (3,8)

TIL 7x
10101111
00011111
10101111
00011111
10101111
00011110
01001110
00100000
NAME Living Room (4,8)

TIL 7y
11111111
01010101
10110110
11111111
11111111
10010101
01000000
00010100
NAME Living Room (5,8)

TIL 7z
01110001
10110001
11010001
11110001
11110001
01010001
01010001
01010001
NAME Living Room (6,8)

TIL 8a
10100010
10010101
01001000
00100101
10010010
00100100
01010001
00000100
NAME Living Room (1,9)

TIL 8b
01001010
01010010
00001000
01010010
10001001
00100100
01010010
10010010
NAME Living Room (2,9)

TIL 8c
01001001
10100100
00010010
10100100
00010010
10100010
01010100
00001010
NAME Living Room (3,9)

TIL 8d
01010101
10001000
00100101
10010010
01000100
00100010
10011001
01000100
NAME Living Room (4,9)

TIL 8e
01000010
10101010
00000100
01010010
10001001
01010100
00000010
10101001
NAME Living Room (5,9)

TIL 8f
10111111
01011111
10111111
00111111
01011111
00111111
10111111
01011111
NAME Living Room (6,9)

TIL 8g
01000100
11111111
11111111
11111111
11111111
11111111
11111111
11101010
NAME Living Room (7,9)

TIL 8h
10000000
11000000
10000000
11000000
11000000
10000000
11000000
00000000
NAME Living Room (8,9)

TIL 8i
00011111
00011011
00011101
00011011
00011111
00001111
00000111
00000011
NAME Living Room (9,9)

TIL 8j
10000010
00000001
10000000
10000000
01100000
11111000
11111110
11111111
NAME Living Room (10,9)

TIL 8k
00100011
10000001
00000000
00000000
00000001
00001111
00111111
11111111
NAME Living Room (11,9)

TIL 8l
11111100
11111100
11111100
11111100
11111100
11111000
11110000
11110000
NAME Living Room (12,9)

TIL 8n
11100001
11001010
11110111
11111101
11101111
11111001
11111000
11111100
NAME Living Room (14,9)

TIL 8o
00010101
01000111
10111101
11111111
11111101
01101001
01111011
01000001
NAME Living Room (15,9)

TIL 8p
11111110
11111110
11111111
11111110
11111110
11111110
11111111
11111110
NAME Living Room (0,10)

TIL 8q
10100010
00010010
01010101
01000000
10010101
01010010
00001000
10100101
NAME Living Room (1,10)

TIL 8r
01001001
00100100
01010010
10001000
00100101
10010010
01001000
00100010
NAME Living Room (2,10)

TIL 8s
01000001
01010100
10010010
01001001
00100100
10010010
01000100
01010010
NAME Living Room (3,10)

TIL 8t
00100010
10010100
01001010
00100001
10010100
01000010
10010100
01001010
NAME Living Room (4,10)

TIL 8u
01000100
10010001
01001010
00100100
10001001
01010100
10000010
01010100
NAME Living Room (5,10)

TIL 8v
00101010
01000100
10101001
00000100
01010010
01001001
10010010
01001000
NAME Living Room (6,10)

TIL 8w
00001010
10100000
00010110
10010000
01000110
00101000
10000100
01010010
NAME Living Room (7,10)

TIL 8x
10000000
01000000
00000000
10000000
01000000
00000000
10000000
01000000
NAME Living Room (8,10)

TIL 8y
11111111
00000000
00000000
00000000
00000000
01000000
00100000
00010000
NAME Living Room (10,10)

TIL 8z
11111111
00000000
00000000
00000000
00000000
00000001
00000010
00000100
NAME Living Room (11,10)

TIL 9a
10010100
00100010
01001010
10101010
00010010
10000100
01010010
10010001
NAME Living Room (7,11)

TIL 9b
10000000
00000000
10000000
00101010
01001000
00000000
11011011
00100100
NAME Living Room (8,11)

TIL 9c
00000000
00000000
00000000
10101010
10001001
00000000
01110000
10000000
NAME Living Room (9,11)

TIL 9d
00001000
00000100
01100010
10100011
10100001
01010000
00111111
00101111
NAME Living Room (10,11)

TIL 9e
00001000
00010000
10100011
11100001
11100010
00000001
11111110
11010101
NAME Living Room (11,11)

TIL 9f
00000000
00000000
00000000
10101010
10100100
10000000
10000111
00000000
NAME Living Room (12,11)

TIL 9g
00000000
00000000
00000000
10101010
00010001
01000000
01011011
01000100
NAME Living Room (13,11)

TIL 9h
01010010
01010000
01010000
01010000
00010000
00010000
01001000
10100010
NAME Living Room (14,11)

TIL 9i
10010101
00000000
00000000
00001000
00000000
00001000
00000000
01001001
NAME Living Room (15,11)

TIL 9j
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME Living Room (0,12)

TIL 9k
11111110
11111111
11111111
11111111
11111111
11111111
11111110
10110101
NAME Living Room (1,12)

TIL 9l
11110100
01011111
00101111
01001111
00111111
01001111
00101111
01011111
NAME Living Room (2,12)

TIL 9m
10010010
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (3,12)

TIL 9n
10101010
11111101
11111110
11111110
11111111
11111110
11111110
11111110
NAME Living Room (4,12)

TIL 9o
01011111
00111111
01011111
00111111
01011111
01011111
10011111
01011111
NAME Living Room (5,12)

TIL 9p
10001010
10100001
10010101
10001011
10101101
10010101
10000111
10101101
NAME Living Room (7,12)

TIL 9q
00010010
01001001
11111111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (8,12)

TIL 9r
00100000
01000000
11110000
11110000
11110000
11111000
11110000
11111000
NAME Living Room (9,12)

TIL 9s
01111111
01111111
01111111
01111111
01111111
01111111
01111111
00111001
NAME Living Room (10,12)

TIL 9t
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00010100
NAME Living Room (11,12)

TIL 9u
10000101
10000010
10000001
10000010
10000010
10000010
00000001
00000010
NAME Living Room (12,12)

TIL 9v
00010001
01001010
00100001
01001000
10100101
00010010
01000000
01010101
NAME Living Room (13,12)

TIL 9w
00010000
01001000
00100000
10001000
00100000
01010000
10001000
01000000
NAME Living Room (14,12)

TIL 9x
00000000
00001000
00000000
00001000
00000000
00001000
00000000
00001000
NAME Living Room (15,12)

TIL 9y
11111111
11111111
11111101
11111111
11111111
11111111
11111111
11111111
NAME Living Room (2,13)

TIL 9z
11111111
11111111
00100100
11111111
11111111
11111111
11111111
11111111
NAME Living Room (3,13)

TIL a0
11111111
11111111
10010111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (4,13)

TIL a1
10010111
10001101
11010111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (7,13)

TIL a2
11110000
11111000
11111111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (9,13)

TIL a3
01100000
11000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (10,13)

TIL a4
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME Living Room (11,13)

TIL a5
00000010
00000001
11111110
11111111
11111111
11111111
11111111
11111111
NAME Living Room (12,13)

TIL a6
10001001
00100100
10101010
11111111
11111111
11111111
11111111
11111111
NAME Living Room (13,13)

TIL a7
00101000
10000101
10110000
11111111
11111111
11111111
11111111
11111111
NAME Living Room (14,13)

TIL a8
00000000
01001001
00001000
11111111
11111111
11111111
11111111
11111111
NAME Living Room (15,13)

TIL a9
00000000
00000000
00000000
00000110
00001101
00001111
00001101
00001111
NAME Hallway3 (5,0)

TIL aa
00000000
00000000
00000000
00000000
10000000
11110000
11111100
11111111
NAME Hallway3 (6,0)

TIL ab
00001011
00001101
00001101
00001011
00001101
00001101
00001011
00001101
NAME Hallway3 (5,1)

TIL ac
10111111
10101111
11010111
10101010
10111101
11011101
10101011
11011111
NAME Hallway3 (6,1)

TIL ad
00000000
11100000
11100000
11100000
11100000
01100000
11100000
11100000
NAME Hallway3 (7,1)

TIL ae
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000110
NAME Hallway3 (2,2)

TIL af
00000000
00000000
00000000
00000011
00001100
00110100
11100100
00100100
NAME Hallway3 (3,2)

TIL ag
00000000
00011000
01101000
10001000
01001000
01001000
01001000
01001000
NAME Hallway3 (4,2)

TIL ah
00001111
00001001
00001111
00001011
00001101
00001110
00001010
00001110
NAME Hallway3 (5,2)

TIL ai
10111101
10111111
10111011
11001011
11110111
01101010
11111010
11101011
NAME Hallway3 (6,2)

TIL aj
01100000
01100000
11100000
11100000
01100000
11100000
11100000
01100000
NAME Hallway3 (7,2)

TIL ak
00000000
00000000
00000000
00011000
00011110
00010111
00011111
00011111
NAME Hallway3 (8,2)

TIL al
00000000
00000000
00000000
00000000
00000000
10000000
11110000
11110000
NAME Hallway3 (9,2)

TIL am
00000010
00011010
00010010
00010010
00010010
00010010
00010010
00010010
NAME Hallway3 (2,3)

TIL an
00100100
00100100
00100101
00100111
00100111
00100111
00101111
00101001
NAME Hallway3 (3,3)

TIL ao
11001000
01101000
11111100
11111100
11111110
11111110
10111110
11101011
NAME Hallway3 (4,3)

TIL ap
00001110
00001011
00001110
00001111
00001011
00001101
00001011
00001101
NAME Hallway3 (5,3)

TIL aq
11110101
11110110
01101010
11110101
11011011
10101010
10101101
11101010
NAME Hallway3 (6,3)

TIL ar
11100000
11100000
11100000
01100000
01100000
11100000
01100000
11100000
NAME Hallway3 (7,3)

TIL as
00011110
00011111
00011110
00011101
00011111
00011111
00011110
00011101
NAME Hallway3 (8,3)

TIL at
10110000
11110000
11110000
10110000
11110000
01110000
11110000
11110000
NAME Hallway3 (9,3)

TIL au
00010010
00010010
00010010
00010011
00011100
00010000
00001100
00000011
NAME Hallway3 (2,4)

TIL av
00111100
00111010
01100111
00000001
00000000
00000000
00000000
00000000
NAME Hallway3 (3,4)

TIL aw
10111110
11011100
01110000
11000000
00000000
00000000
00000000
00000000
NAME Hallway3 (4,4)

TIL ax
11001110
11101100
00011000
00000100
00000001
00000000
00000000
00000000
NAME Hallway3 (5,4)

TIL ay
11111011
00111101
10001110
00000011
01001000
00010000
00000100
00000011
NAME Hallway3 (6,4)

TIL az
01100000
11100000
01100000
11100000
11100000
11100000
01100000
01100000
NAME Hallway3 (7,4)

TIL b0
00011111
00011011
00011101
00000110
00000001
00000000
00000000
00000000
NAME Hallway3 (8,4)

TIL b1
11110000
01110000
11110000
01110000
11010000
01110000
00000000
00000000
NAME Hallway3 (9,4)

TIL b2
01100000
01000000
00011000
00000110
00000001
00000000
00000000
00000000
NAME Hallway3 (3,5)

TIL b3
00000000
00000000
00000000
00000000
11000000
00110000
00001100
00000011
NAME Hallway3 (4,5)

TIL b4
01100000
01000000
00010111
00001111
00011000
00011010
00011111
00011111
NAME Hallway3 (7,5)

TIL b5
00000000
00000000
11000001
01100111
10111100
01101001
11111000
11110111
NAME Hallway3 (8,5)

TIL b6
00000000
00000000
10000000
01110000
11011100
00001010
01011110
01110110
NAME Hallway3 (9,5)

TIL b7
11100000
00100000
00011000
00000110
00000001
00000000
00000000
00000000
NAME Hallway3 (5,6)

TIL b8
00000000
00000000
00000000
00000000
10000000
00110000
00001100
00000011
NAME Hallway3 (6,6)

TIL b9
00001100
00001100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway3 (7,6)

TIL ba
11111111
11111110
01111111
11111001
00111001
00000001
00000010
00000000
NAME Hallway3 (8,6)

TIL bb
10111110
11111110
11111110
11101110
11101111
11100000
11000100
00000001
NAME Hallway3 (9,6)

TIL bc
00000000
00000000
00000000
00000000
10000000
01110000
01001000
01111000
NAME Hallway3 (10,6)

TIL bd
00000000
00000000
00000000
00000000
00000000
00000000
00110000
11111100
NAME Hallway3 (6,7)

TIL be
11100000
00010000
00011000
00000110
00000001
00000000
00000000
00000000
NAME Hallway3 (7,7)

TIL bf
00000000
00000000
00000000
00000000
10000000
01110001
00011010
00011010
NAME Hallway3 (8,7)

TIL bg
00010001
00000101
00000110
00001001
01010101
01010110
10111000
11000000
NAME Hallway3 (9,7)

TIL bh
00101000
10101100
01011100
01110011
10000000
00000011
00001110
01110101
NAME Hallway3 (10,7)

TIL bi
00000000
00000000
00000000
00000000
10000000
10000000
10000000
11000000
NAME Hallway3 (11,7)

TIL bj
11111111
11111111
11111111
11111111
11101101
11111101
11101101
11111101
NAME Hallway3 (6,8)

TIL bk
00000000
11000000
11100000
11111000
11111110
01011110
01101110
11010110
NAME Hallway3 (7,8)

TIL bl
00011011
00001100
00001110
00000011
00000001
00000001
00000001
00000000
NAME Hallway3 (8,8)

TIL bm
00000000
00000001
00000110
00001001
10101011
01010110
10111001
11100100
NAME Hallway3 (9,8)

TIL bn
10010110
01011010
10101010
01110101
10010010
01010111
00001101
01111110
NAME Hallway3 (10,8)

TIL bo
10111000
11111100
00010100
11111100
11010100
01101110
10111111
11101001
NAME Hallway3 (11,8)

TIL bp
00000000
00000000
00000000
00000000
00000000
00000001
10000010
01000010
NAME Hallway3 (12,8)

TIL bq
00000000
00000000
00000000
00000000
00000000
10000000
11000000
01000000
NAME Hallway3 (13,8)

TIL br
00000000
00000000
00000000
00000000
00000000
00110000
11111000
11110100
NAME Hallway3 (4,9)

TIL bs
00000000
00000000
00000000
00000000
00000000
00000000
00000100
00001010
NAME Hallway3 (5,9)

TIL bt
11011011
11111101
11101101
11111101
11011011
11111101
11101101
11111111
NAME Hallway3 (6,9)

TIL bu
11101010
10111110
11011110
11111010
11011110
10111010
01011110
10111010
NAME Hallway3 (7,9)

TIL bv
00011001
00001111
00001111
00001111
00001101
00000111
00000001
00000000
NAME Hallway3 (9,9)

TIL bw
11110111
11011001
01111101
11100101
10010101
01010111
10101101
11111011
NAME Hallway3 (10,9)

TIL bx
00100101
01010111
01011110
01110101
11011011
01101110
01111011
11010101
NAME Hallway3 (11,9)

TIL by
11000010
11000010
11100010
11110100
10111100
11011111
01110101
10101111
NAME Hallway3 (12,9)

TIL bz
01000000
01100000
01100000
00110111
01011111
01111111
01111111
01111011
NAME Hallway3 (13,9)

TIL c0
00000000
00000000
00000000
00000000
10000000
11000000
11000000
11000000
NAME Hallway3 (14,9)

TIL c1
00000000
00000000
00000000
00000000
00000000
00000001
00000010
00000101
NAME Hallway3 (2,10)

TIL c2
00000001
00000001
00000001
00000001
00000001
11100011
00010011
11101011
NAME Hallway3 (3,10)

TIL c3
11001100
11110100
11101100
11011100
11101100
11111111
11111111
01011101
NAME Hallway3 (4,10)

TIL c4
00000010
00000100
00000100
00001110
00011110
00011110
11011110
11011110
NAME Hallway3 (5,10)

TIL c5
11110011
11110111
11110110
11110111
11110111
11110110
11111111
11011101
NAME Hallway3 (6,10)

TIL c6
01010110
01101110
10101010
01101110
01010110
10110110
01011010
01101110
NAME Hallway3 (7,10)

TIL c7
11101110
11011011
01111101
01111011
00111101
00011011
01111010
11111101
NAME Hallway3 (10,10)

TIL c8
10101110
01110101
10101110
01110101
10101101
01101011
11110110
00111011
NAME Hallway3 (11,10)

TIL c9
10110111
11011011
10101101
10110110
01101101
10110111
11011010
01101101
NAME Hallway3 (12,10)

TIL ca
11111011
11111101
11111111
11111111
01011111
10111110
11111000
11000000
NAME Hallway3 (13,10)

TIL cb
11000000
11000000
11000000
11000000
10000000
00000000
00000000
00000000
NAME Hallway3 (14,10)

TIL cc
00000111
00000111
00000110
00000110
00000111
00001110
00011110
00001111
NAME Hallway3 (2,11)

TIL cd
11111111
10101111
00101101
00011101
11101101
00001101
00011010
11110000
NAME Hallway3 (3,11)

TIL ce
10110100
11101011
11111011
01111111
00101101
01010101
00000010
00000000
NAME Hallway3 (4,11)

TIL cf
11111110
11111100
11111100
01111100
01111110
01111111
11111100
01110000
NAME Hallway3 (5,11)

TIL cg
11111101
11101100
11111111
11101110
11111011
11100110
10110101
00001010
NAME Hallway3 (6,11)

TIL ch
10101010
10101110
01010110
10110110
11010110
11111010
01111110
10010110
NAME Hallway3 (7,11)

TIL ci
00000011
00000011
00000011
00000010
00000111
00011101
01101010
01111010
NAME Hallway3 (9,11)

TIL cj
10101011
11110110
01011011
11110101
00011110
11010011
11110101
10011101
NAME Hallway3 (10,11)

TIL ck
10001110
11100101
01111010
10111010
11010111
01101101
11011011
00111101
NAME Hallway3 (11,11)

TIL cl
10110111
11011100
11111000
01111000
01011000
10011000
01110000
10000000
NAME Hallway3 (12,11)

TIL cm
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway3 (2,12)

TIL cn
11100000
11100000
00011010
00011100
00000111
00000001
00000000
00000000
NAME Hallway3 (3,12)

TIL co
10010001
00000100
00000000
00100000
00000000
11000010
00111000
00001100
NAME Hallway3 (4,12)

TIL cp
00000010
00100000
00000000
10001000
00000001
00000000
00100000
00000100
NAME Hallway3 (5,12)

TIL cq
00000011
01000000
00010000
00000100
00000000
00000000
00100010
10000000
NAME Hallway3 (6,12)

TIL cr
01010110
11010110
00101010
10010110
00000110
01000001
00001001
00000000
NAME Hallway3 (7,12)

TIL cs
00000000
00000000
00000011
00000011
00000101
10000111
01110100
00001100
NAME Hallway3 (8,12)

TIL ct
01100110
11100001
11010000
00111000
01001110
01010011
11010100
00011010
NAME Hallway3 (9,12)

TIL cu
10100111
01010010
01011001
01010101
00001101
10000011
11110000
00011100
NAME Hallway3 (10,12)

TIL cv
01000111
11110101
01011011
01101111
00101110
01111000
11110000
00110000
NAME Hallway3 (11,12)

TIL cw
10000000
11110000
00011001
00011110
00000110
00000001
00000000
00000000
NAME Hallway3 (5,13)

TIL cx
00000000
00010010
00000000
00100010
00001000
11000000
01110010
00001100
NAME Hallway3 (6,13)

TIL cy
00100000
00000010
00000000
01000000
00001000
00100001
00000000
10001001
NAME Hallway3 (7,13)

TIL cz
00000110
00010000
01000000
00000000
00000000
00010010
01000000
00000010
NAME Hallway3 (8,13)

TIL d0
00000111
11000000
00010000
00010100
00000010
01000001
00000000
00000000
NAME Hallway3 (9,13)

TIL d1
11000011
10111010
01010011
00100111
00000110
00000010
00000010
00001100
NAME Hallway3 (10,13)

TIL d2
00110000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway3 (11,13)

TIL d3
00000011
00001100
00010000
00001000
00001100
00000011
00000000
00000000
NAME Hallway3 (6,14)

TIL d4
00100000
10000000
00000000
00000000
00000000
00000000
11100000
00011000
NAME Hallway3 (7,14)

TIL d5
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00001100
NAME Hallway3 (8,14)

TIL d6
00000000
00000001
00000110
00001000
00011000
11100000
00000000
00000000
NAME Hallway3 (9,14)

TIL d7
01110000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway3 (10,14)

TIL d8
00000110
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hallway3 (7,15)

TIL 8m
00000000
00001000
01000000
00000000
00000000
00001001
00100000
00000000
NAME OuterWorld (0,0)

TIL d9
00000000
00100000
10000010
00000000
00000000
00010001
00000000
00000000
NAME OuterWorld (1,0)

TIL da
00000000
00010000
01000001
00000000
00000000
00010010
00000000
00000000
NAME OuterWorld (2,0)

TIL db
00000000
01000000
00000100
00000000
00000000
00100100
00000000
00000000
NAME OuterWorld (3,0)

TIL dc
00000000
00100000
10000010
00000000
00000000
00100100
00000000
10000000
NAME OuterWorld (4,0)

TIL dd
00000000
00010000
01000001
00000000
00000000
01001001
00000000
00000000
NAME OuterWorld (5,0)

TIL de
00000000
00001000
00100000
00000000
00000000
00001001
00100000
00000000
NAME OuterWorld (6,0)

TIL df
00000000
00000000
10010010
00000000
00000000
00010001
00000000
00000000
NAME OuterWorld (7,0)

TIL dg
00000000
00000000
01001001
00000000
00000000
00010001
00000000
00000000
NAME OuterWorld (8,0)

TIL dh
00000000
00000000
00100100
00000000
00000000
00010001
00000000
00000000
NAME OuterWorld (9,0)

TIL di
00000000
01000000
00001001
00000000
00000000
00100001
00000100
00000000
NAME OuterWorld (11,0)

TIL dj
00000000
00000100
00100000
00000000
00000001
00010000
00000000
00000010
NAME OuterWorld (12,0)

TIL dk
00000000
00000000
01001001
00000000
00000000
00001000
00100000
00000000
NAME OuterWorld (13,0)

TIL dl
00000000
00010000
00000001
00000000
00100000
10000100
00000000
00000000
NAME OuterWorld (14,0)

TIL dm
00000000
01000000
00000100
00000000
00010000
01000000
00000000
00000100
NAME OuterWorld (15,0)

TIL dn
00000000
00010010
01000000
00000000
00000000
00001000
00100000
00000000
NAME OuterWorld (0,1)

TIL do
10001000
00000000
00000000
00100010
10000000
00000000
00001000
00100000
NAME OuterWorld (1,1)

TIL dp
10000001
00010000
00000000
00000010
01000000
00000000
00001000
10000000
NAME OuterWorld (2,1)

TIL dq
00010000
00000010
00000000
01000000
00000100
00000000
00010000
10000000
NAME OuterWorld (3,1)

TIL dr
00000100
00010000
00000000
00000000
01000100
00000000
00000000
10001000
NAME OuterWorld (4,1)

TIL ds
10000000
00001001
00000000
01000000
00000010
00001000
10000000
00000000
NAME OuterWorld (5,1)

TIL dt
00000000
00010010
00000000
00000000
00100000
00000010
00000000
10001000
NAME OuterWorld (6,1)

TIL du
10001000
00000000
00000000
00100100
10000000
00000000
00000000
00010010
NAME OuterWorld (7,1)

TIL dv
10001000
00000000
00100000
10000010
00000000
00000000
00100100
00000000
NAME OuterWorld (8,1)

TIL dw
10001000
00000000
00000000
01001001
00000000
00000000
00000000
01001001
NAME OuterWorld (9,1)

TIL dx
10001000
00000000
00000000
00100100
00000000
00000000
00000010
00100000
NAME OuterWorld (10,1)

TIL dy
10000000
00001000
00000000
01000001
00000100
00000000
00100000
00000000
NAME OuterWorld (11,1)

TIL dz
01000000
00001000
00000000
00000000
00100010
00000000
00000000
10001000
NAME OuterWorld (12,1)

TIL e0
00000010
00100000
10000000
00000010
00001000
00000000
00100000
10000001
NAME OuterWorld (13,1)

TIL e1
00010001
01000000
00000000
00000010
00010000
00000000
01000000
00000000
NAME OuterWorld (14,1)

TIL e2
00010000
00000000
00000000
00100010
00000000
00000000
10001000
00000000
NAME OuterWorld (15,1)

TIL e3
00000001
00001000
01000000
00000000
00000010
00010000
00000000
01000000
NAME OuterWorld (0,2)

TIL e4
00000000
00000010
00000000
01001000
00000000
00000000
00000010
10010000
NAME OuterWorld (1,2)

TIL e5
00000010
00010000
00000000
00000000
01000100
00000000
00000000
00100010
NAME OuterWorld (2,2)

TIL e6
00000000
00000100
00010000
01000000
00000001
00000000
10001000
00000000
NAME OuterWorld (3,2)

TIL e7
00000000
00000001
01000100
00000000
00000000
00010001
00000000
01000000
NAME OuterWorld (4,2)

TIL e8
00010000
00000000
00000010
00001000
01000000
00000000
00000001
00010000
NAME OuterWorld (5,2)

TIL e9
00000000
00000001
01000100
00000000
00000000
00010001
00000000
00000000
NAME OuterWorld (6,2)

TIL ea
01000000
00000000
00000001
00001000
00100000
00000000
00000001
00001000
NAME OuterWorld (7,2)

TIL eb
00000000
01000010
00000000
00001000
00000000
00100000
00000000
00000100
NAME OuterWorld (8,2)

TIL ec
00000000
00000000
00100010
00000000
10000000
00001000
00000000
01000000
NAME OuterWorld (9,2)

TIL ed
00000000
00001001
00100000
00000000
00000000
10001000
00000000
00000001
NAME OuterWorld (10,2)

TIL ee
00000100
00010000
00000000
00000000
10001000
00000000
00000001
00100000
NAME OuterWorld (11,2)

TIL ef
00000000
00000000
00100010
10000000
00000000
00001001
00000000
00100000
NAME OuterWorld (12,2)

TIL eg
00000000
00001000
00100000
00000001
00000000
00010000
00000000
00000010
NAME OuterWorld (13,2)

TIL eh
00000100
00010000
01000000
00000000
00000010
00001000
10000000
00000000
NAME OuterWorld (14,2)

TIL ei
00000000
00100010
10000000
00000000
00001000
00000000
00100000
10000001
NAME OuterWorld (15,2)

TIL ej
00000010
00001000
00000000
00100000
00000001
00000000
00010000
01000001
NAME OuterWorld (0,3)

TIL ek
00000000
00000000
00000100
01000000
00000001
00010100
00000000
00100000
NAME OuterWorld (1,3)

TIL el
00000000
10000000
00001000
00000000
00100010
00001000
00000000
01000000
NAME OuterWorld (2,3)

TIL em
00000001
00100000
10000100
00000000
00010000
10000001
00001000
00100100
NAME OuterWorld (3,3)

TIL en
00000100
00000000
00000000
00100010
00000000
00000000
00001000
00100000
NAME OuterWorld (4,3)

TIL eo
01000000
00000010
00000000
00100000
00000001
10000100
00000000
00010000
NAME OuterWorld (5,3)

TIL ep
00100010
00000000
00000000
00010000
00000010
00000000
00010000
01000000
NAME OuterWorld (6,3)

TIL eq
00100000
00000000
10000010
00000000
00001000
00100000
00000000
00000000
NAME OuterWorld (7,3)

TIL er
00000000
01000000
00001001
00000000
00000000
10010000
00000000
00000010
NAME OuterWorld (8,3)

TIL es
00000100
00000000
00100001
00000000
00000100
10000000
00000000
00010000
NAME OuterWorld (9,3)

TIL et
01000100
00000000
00010000
00000000
00000010
00100000
10000000
00000001
NAME OuterWorld (10,3)

TIL eu
00000000
00000100
00010000
10000000
00000000
00000010
00010000
00000000
NAME OuterWorld (11,3)

TIL ev
00000000
00000100
10000000
00000000
00010001
00000000
00000000
01001000
NAME OuterWorld (12,3)

TIL ew
10001000
00000000
00000000
01000100
00000000
00000000
00010000
10000010
NAME OuterWorld (13,3)

TIL ex
00000010
00010000
01000000
00000000
00000010
10001000
00000000
00000000
NAME OuterWorld (14,3)

TIL ey
00000000
00001000
00000000
01000000
00000100
00000000
00010000
01000000
NAME OuterWorld (15,3)

TIL ez
00000000
00000000
00001000
00100001
00000000
00000000
00010000
01000000
NAME OuterWorld (0,4)

TIL f0
00010101
00001000
00000010
00100000
00000000
00000000
10001001
00000000
NAME OuterWorld (1,4)

TIL f1
01010110
00000000
01001000
10000100
00010001
00000000
00000000
00010000
NAME OuterWorld (2,4)

TIL f2
10100000
00001000
10000001
01010000
00000000
00000010
00001000
01000000
NAME OuterWorld (3,4)

TIL f3
00000001
00000000
00100000
00000100
00000000
00000000
00100010
00000000
NAME OuterWorld (4,4)

TIL f4
00000000
00000001
00010000
01000000
00000000
00000100
00100000
00000000
NAME OuterWorld (5,4)

TIL f5
00000010
00000000
00001000
00100000
10000000
00000010
00000000
00010000
NAME OuterWorld (6,4)

TIL f6
01000100
00000000
00000000
00100010
10000000
00000000
00001001
00100000
NAME OuterWorld (7,4)

TIL f7
10001000
00000000
00000000
00100010
00000000
00000000
00010001
00000000
NAME OuterWorld (8,4)

TIL f8
00000010
00000000
10010000
00000000
00000010
00000000
00100000
00000100
NAME OuterWorld (9,4)

TIL f9
00001000
00000000
01000000
00000100
00000000
00010000
10000000
00000010
NAME OuterWorld (10,4)

TIL fa
00000001
00100000
10000000
00000100
00000000
00010000
10000001
00000000
NAME OuterWorld (11,4)

TIL fb
00000000
00000000
00000100
01000000
00000000
00001000
00100000
00000000
NAME OuterWorld (12,4)

TIL fc
00000000
00000000
00100010
10000000
00000000
00001001
10000000
00000001
NAME OuterWorld (13,4)

TIL fd
00100010
00000000
00000000
00100000
00000100
00010000
01000010
00000000
NAME OuterWorld (14,4)

TIL fe
00000001
00000100
00010000
10000000
00000000
00010010
10000000
00010000
NAME OuterWorld (15,4)

TIL ff
00000010
00000000
00001000
00100000
00000001
00000000
00001000
01000000
NAME OuterWorld (0,5)

TIL fg
00000000
00100000
00000010
00000000
00010000
00000000
00000010
01000000
NAME OuterWorld (1,5)

TIL fh
00000010
10000000
00000000
00010001
00000000
10000000
00000100
00010000
NAME OuterWorld (2,5)

TIL fi
00000000
00000001
00001000
00100000
00000000
00000001
00000100
01000000
NAME OuterWorld (3,5)

TIL fj
00000000
00100100
00000000
00000001
00010011
00000111
00011111
00011111
NAME OuterWorld (4,5)

TIL fk
00000000
10000100
00111000
11111111
11111111
11111111
11111111
11111111
NAME OuterWorld (5,5)

TIL fl
10000000
00000010
00000000
10010000
11000000
11100010
11110000
11111000
NAME OuterWorld (6,5)

TIL fm
10000000
00000001
00000100
00010000
10000000
00000000
00000100
00100000
NAME OuterWorld (7,5)

TIL fn
00000100
00100000
00000000
00000010
00100000
10000000
00000001
00001000
NAME OuterWorld (8,5)

TIL fo
00000000
00100000
10000010
00000000
00001010
00000000
00000100
00100010
NAME OuterWorld (9,5)

TIL fp
00001000
00100000
10000010
00101000
00000000
00000000
10101010
00000100
NAME OuterWorld (10,5)

TIL fq
00000000
00100100
10000000
00101000
00000001
00000000
10101010
10000100
NAME OuterWorld (11,5)

TIL fr
00000010
00100000
10000000
00000100
00000000
00010000
10000001
00000000
NAME OuterWorld (12,5)

TIL fs
00010010
00000001
00000000
01000100
00000000
00000000
00100010
00000000
NAME OuterWorld (13,5)

TIL ft
00000000
00101010
10110110
01000000
00001001
00000000
00100001
00000000
NAME OuterWorld (14,5)

TIL fu
00000000
10101010
11010101
00000000
00100100
00010001
00000000
00000000
NAME OuterWorld (15,5)

TIL fv
00000001
00000000
00010000
00000001
01000000
00000100
00000000
00010000
NAME OuterWorld (0,6)

TIL fw
00000000
00001000
00000000
00100000
00000010
00000000
00010000
10000000
NAME OuterWorld (1,6)

TIL fx
00000000
10000001
00000100
00010000
00000000
01000000
00000010
00001000
NAME OuterWorld (2,6)

TIL fy
00000000
00001000
00000000
00100000
00000010
10000000
00001000
00000000
NAME OuterWorld (3,6)

TIL fz
00011111
10111111
00111111
00111111
01111111
00111111
01111111
01111111
NAME OuterWorld (4,6)

TIL g0
11111000
11111100
11111100
11111100
11111100
11111000
11111100
11111010
NAME OuterWorld (6,6)

TIL g1
10000000
00000001
00001000
00100000
00000000
10000010
00001000
00000000
NAME OuterWorld (7,6)

TIL g2
00100000
00000000
00000010
00001000
01000000
00000000
00000100
00100000
NAME OuterWorld (8,6)

TIL g3
00000001
00000000
00100000
00000100
00000000
10010000
00000000
00000010
NAME OuterWorld (9,6)

TIL g4
01010000
00000101
00100000
10000000
00000100
00000000
10010000
00000001
NAME OuterWorld (10,6)

TIL g5
00010001
01000100
00010000
00000000
01000001
00000000
00001000
00000000
NAME OuterWorld (11,6)

TIL g6
00001000
00000000
00000001
01000100
00000000
00000000
00010001
10000000
NAME OuterWorld (12,6)

TIL g7
00000000
00100010
00000000
00000000
00010010
01000000
00000000
00000001
NAME OuterWorld (13,6)

TIL g8
00000100
00100000
00000000
00000001
01000100
00000000
00000000
00010001
NAME OuterWorld (14,6)

TIL g9
00010000
01000001
00000000
00000100
00000000
00100000
00000000
00000100
NAME OuterWorld (15,6)

TIL ga
00000000
01000000
00000100
00000000
00010000
00000001
01000000
00000100
NAME OuterWorld (0,7)

TIL gb
00000010
00001000
01000000
00000000
00000010
00010000
00000000
00000000
NAME OuterWorld (1,7)

TIL gc
00100000
00000000
00000010
10001000
00000000
00000000
00100010
10000000
NAME OuterWorld (2,7)

TIL gd
00100000
00000010
00000000
01000000
00001000
00000001
00000000
01000100
NAME OuterWorld (3,7)

TIL ge
00111111
01111111
00111111
01111111
00111111
01111111
00111111
01111111
NAME OuterWorld (4,7)

TIL gf
11111100
11111010
11111000
11111100
11111010
11111010
11111000
11111100
NAME OuterWorld (6,7)

TIL gg
00100000
00000010
00000000
10001000
00000000
00101000
11010111
01101011
NAME OuterWorld (7,7)

TIL gh
10000000
00000010
00001000
00100000
10000000
00000000
00000100
10000000
NAME OuterWorld (8,7)

TIL gi
01000000
00001000
00000000
00000000
10010010
00000000
00000000
01000100
NAME OuterWorld (9,7)

TIL gj
00000000
00010000
10000010
00000000
00001000
00100000
00000001
10000000
NAME OuterWorld (10,7)

TIL gk
00100000
00000010
00000000
01001000
00000000
00000000
00010000
00000010
NAME OuterWorld (11,7)

TIL gl
00000100
00000000
00100000
00000010
10000000
00001000
00000000
00100000
NAME OuterWorld (12,7)

TIL gm
00010000
01000000
00000010
00000000
00100000
00000010
10000000
00001000
NAME OuterWorld (13,7)

TIL gn
00000000
00000000
01001001
00000000
00000000
00010000
01000010
00000000
NAME OuterWorld (14,7)

TIL go
00010000
01000000
00000000
00000010
00001000
10000000
00000000
00010000
NAME OuterWorld (15,7)

TIL gp
00000000
00010000
00000000
01000010
00000000
00000000
00010001
10000000
NAME OuterWorld (0,8)

TIL gq
01000100
00000000
00010000
01000001
00000000
00000100
00010000
00000000
NAME OuterWorld (1,8)

TIL gr
00000000
00001000
00100001
00000000
00000000
00001000
00100000
00000000
NAME OuterWorld (2,8)

TIL gs
00000000
00000000
00100100
00000000
00000000
10000100
00010000
00000001
NAME OuterWorld (3,8)

TIL gt
00111111
01111111
00111111
01111111
01111111
00111111
01111111
11111111
NAME OuterWorld (4,8)

TIL gu
11111011
11111010
11111101
11111101
11111110
11111101
11111110
11111000
NAME OuterWorld (6,8)

TIL gv
00001001
10110101
01010110
10101011
11010001
01011010
10101011
01000101
NAME OuterWorld (7,8)

TIL gw
11000001
01001000
11100000
01100000
11010010
11100000
01101000
10100000
NAME OuterWorld (8,8)

TIL gx
00000000
00000000
00010010
01000000
00000000
00000100
00100000
10000000
NAME OuterWorld (9,8)

TIL gy
00001000
00000000
00100000
00000010
00001000
10000000
00000000
00100010
NAME OuterWorld (10,8)

TIL gz
00000000
10010000
00000001
00000000
00010000
01000001
00000000
00000100
NAME OuterWorld (11,8)

TIL h0
00000010
00000000
00010000
00000001
01000100
00000000
00000000
00010001
NAME OuterWorld (12,8)

TIL h1
00000000
00100001
00000000
00000100
00010000
00000000
01000001
00000000
NAME OuterWorld (13,8)

TIL h2
00000000
00010001
00000000
00000000
01001001
00000000
00000000
00000100
NAME OuterWorld (14,8)

TIL h3
00000010
00000000
00100000
00000000
00000100
00010000
00000000
01000000
NAME OuterWorld (15,8)

TIL h4
10000000
10000100
10000000
10100000
10001010
10000000
10000000
10101010
NAME OuterWorld (0,9)

TIL h5
00000001
10010000
00000000
00001000
10100010
00000000
00000001
10101010
NAME OuterWorld (1,9)

TIL h6
00000010
00010000
00000000
10000000
00001001
00000000
00000000
00100000
NAME OuterWorld (2,9)

TIL h7
00000111
01011111
00011111
00111111
01111111
01111111
01111111
11111111
NAME OuterWorld (3,9)

TIL h8
11111101
11111000
11111110
11111101
11111111
11111111
11111111
11111111
NAME OuterWorld (6,9)

TIL h9
00010010
01000011
10010101
01111010
11001101
11110110
11111011
11111101
NAME OuterWorld (7,9)

TIL ha
11100010
01101000
11100000
10100100
11100000
10100000
01101001
11101010
NAME OuterWorld (8,9)

TIL hb
00000001
00001000
00100000
10000000
00001000
01000000
00001001
01000100
NAME OuterWorld (9,9)

TIL hc
00000000
00000000
00010010
10000000
00000000
00001000
00100000
00000000
NAME OuterWorld (10,9)

TIL hd
00100000
10000000
00000001
00001000
00000000
10000001
00010000
00000000
NAME OuterWorld (11,9)

TIL he
01000000
00000000
00000100
00000000
00101111
00010100
00101010
01100010
NAME OuterWorld (12,9)

TIL hf
00001000
00100000
00000000
10000010
10100000
11100000
00110001
11011000
NAME OuterWorld (13,9)

TIL hg
00100000
10000000
00000010
00001000
00000000
01000000
00000010
00001000
NAME OuterWorld (14,9)

TIL hh
00000010
00001000
00100000
00000000
00000010
10001001
00000010
00000101
NAME OuterWorld (15,9)

TIL hi
10011010
10000000
10010010
10000100
10110010
11110001
11111100
11111111
NAME OuterWorld (0,10)

TIL hj
10101000
00000010
10001000
00100000
10001000
00100000
00000001
01000100
NAME OuterWorld (1,10)

TIL hk
00000100
00000000
00100000
10000000
00000100
00000000
00010000
00000000
NAME OuterWorld (2,10)

TIL hl
11111110
11111111
11111111
11111110
11111111
11111111
11111111
11111111
NAME OuterWorld (7,10)

TIL hm
11110101
01100000
10100010
11100100
01100000
11100100
10100000
11100100
NAME OuterWorld (8,10)

TIL hn
10101000
00000000
01010000
00000000
00000010
10001000
00000000
00000000
NAME OuterWorld (9,10)

TIL ho
00000010
00010000
10000000
00000000
00000100
00100000
10000001
00000100
NAME OuterWorld (10,10)

TIL hp
00000010
01001000
00000000
00000000
10000010
00010000
00100100
00000000
NAME OuterWorld (11,10)

TIL hq
10101101
10101010
10010101
11010110
10101010
00001001
00000000
01010100
NAME OuterWorld (12,10)

TIL hr
01101100
10111000
01011101
01101100
01011100
01101101
10110100
01011100
NAME OuterWorld (13,10)

TIL hs
00000000
01000000
00000010
00001000
00000000
00000000
00010001
01000000
NAME OuterWorld (14,10)

TIL ht
00100110
10000100
00001010
00001101
00001001
01001101
00001000
00001100
NAME OuterWorld (15,10)

TIL hu
10000000
11000000
11000100
11000000
11100000
11100000
11100010
11110000
NAME OuterWorld (1,11)

TIL hv
00000000
00100010
00000111
00011111
10111111
01111111
01111111
11111111
NAME OuterWorld (2,11)

TIL hw
01100000
11100100
10100000
11100100
01100000
11100100
10100000
11100100
NAME OuterWorld (8,11)

TIL hx
01000100
00000000
00010111
00010101
01101010
00110001
01001101
11010110
NAME OuterWorld (9,11)

TIL hy
00000001
01000001
10001000
01100000
10110000
01011100
01110100
10110100
NAME OuterWorld (10,11)

TIL hz
00000000
01011111
00000000
01000000
00010010
00000000
01000000
00000010
NAME OuterWorld (11,11)

TIL i0
00000010
11111010
00010101
11101010
00110110
11011010
01010101
10101010
NAME OuterWorld (12,11)

TIL i1
10111101
11010100
01111100
01010100
01101100
10111110
01011101
11101100
NAME OuterWorld (13,11)

TIL i2
00000000
00000100
10010000
00000000
00000000
10101010
01101101
00000000
NAME OuterWorld (14,11)

TIL i3
00001010
10001010
00100000
10000010
00000000
01010101
10101101
00001010
NAME OuterWorld (15,11)

TIL i4
11100001
11100001
11101001
11100011
11100001
11100011
11110001
11101101
NAME OuterWorld (1,12)

TIL i5
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME OuterWorld (7,12)

TIL i6
01100000
11100100
10100000
01100100
00000000
10010000
00000100
01010101
NAME OuterWorld (8,12)

TIL i7
10101010
10010101
11010110
10010010
00001000
00100010
10000000
01011011
NAME OuterWorld (9,12)

TIL i8
01011110
01101100
01011100
10110101
10111100
01011101
01101100
10111001
NAME OuterWorld (10,12)

TIL i9
00001000
00100000
00000000
00001011
00011111
01111111
01111111
11111111
NAME OuterWorld (11,12)

TIL ia
10101011
10001010
10101011
10101101
11111010
11111111
11111111
11111111
NAME OuterWorld (12,12)

TIL ib
00111100
11010100
01111100
01010100
10111100
01101100
10111100
10101100
NAME OuterWorld (13,12)

TIL ic
00100010
10001000
00000001
10001000
00000000
10010000
00010000
10000101
NAME OuterWorld (14,12)

TIL id
01001100
00100110
00001010
00010101
10000101
00001010
00101011
10001111
NAME OuterWorld (15,12)

TIL ie
11111111
11111111
11111111
11111111
11111111
11111011
11110000
11100010
NAME OuterWorld (0,13)

TIL if
11110011
11100001
11100101
11100011
11101001
01000001
00000000
01010101
NAME OuterWorld (1,13)

TIL ig
11111111
11111111
11111111
11111111
11111111
01101100
00000000
00101010
NAME OuterWorld (2,13)

TIL ih
11111111
11111111
11111111
11111111
11111111
11011011
00000000
01010101
NAME OuterWorld (3,13)

TIL ii
11111111
11111111
11111111
11111111
11111111
01101101
00000000
01010101
NAME OuterWorld (4,13)

TIL ij
11111111
11111111
11111111
11111111
11111111
10110110
00000000
01010101
NAME OuterWorld (5,13)

TIL ik
11111111
11111111
11111111
11111111
11111111
11111111
00111111
00011111
NAME OuterWorld (6,13)

TIL il
11111111
11111110
11111111
11111110
11111111
11111111
11111111
11111111
NAME OuterWorld (7,13)

TIL im
00101001
10000000
00010100
10000010
01101010
11100000
01100100
11100010
NAME OuterWorld (8,13)

TIL in
01101101
10100101
11001011
10101010
11010101
10101011
10110101
01011010
NAME OuterWorld (9,13)

TIL io
01011100
01101101
10111101
10101111
01110111
01011111
01101111
00111111
NAME OuterWorld (10,13)

TIL ip
11110100
10101100
11111101
11011100
11101101
11110100
11011100
11101100
NAME OuterWorld (13,13)

TIL iq
00010000
00000010
00000001
01010100
01010101
00000000
10010010
01000000
NAME OuterWorld (14,13)

TIL ir
01010111
00001111
01001111
00101111
10101111
00001111
01011111
10001111
NAME OuterWorld (15,13)

TIL is
10001000
11000010
10010000
11001010
11110101
11111111
11111111
00111111
NAME OuterWorld (0,14)

TIL it
10000000
00010010
01000000
10010101
01010101
11111111
11010011
11100001
NAME OuterWorld (1,14)

TIL iu
00000000
10100101
00001000
01010010
01010101
10111011
11111111
11111110
NAME OuterWorld (2,14)

TIL iv
00000000
01001001
00000100
10101001
01010101
11111111
00100100
00010001
NAME OuterWorld (3,14)

TIL iw
00000000
00100100
01000010
00010001
01101101
10110111
11011010
00000001
NAME OuterWorld (4,14)

TIL ix
00000000
10010010
00000100
01010001
01011101
11101011
01011101
00000000
NAME OuterWorld (5,14)

TIL iy
10001111
00100111
00001111
01011111
01101111
10111111
11111111
00010101
NAME OuterWorld (6,14)

TIL iz
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10110100
NAME OuterWorld (7,14)

TIL j0
10101000
11100010
01100000
11100000
10101010
11110010
01011010
00000000
NAME OuterWorld (8,14)

TIL j1
11010110
01011010
10101000
11000101
10101000
11010101
10101011
00000000
NAME OuterWorld (9,14)

TIL j2
11011111
10101111
00100011
00000111
01010011
01001111
01101011
00000101
NAME OuterWorld (10,14)

TIL j3
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01101111
NAME OuterWorld (11,14)

TIL j4
11111100
11010100
11000100
10010001
11000010
11011001
11101101
10000000
NAME OuterWorld (13,14)

TIL j5
10000100
00100001
00000100
00010010
00101101
01000110
10000001
00010000
NAME OuterWorld (14,14)

TIL j6
00101111
00011111
01001111
00101111
11011111
11111111
01011111
00001111
NAME OuterWorld (15,14)

TIL j7
00001111
00100111
00001111
00100111
00001111
01010111
10111111
11111111
NAME OuterWorld (0,15)

TIL j8
11101011
11100001
11110111
11101001
11100011
11101001
11100011
11101001
NAME OuterWorld (1,15)

TIL j9
11111100
11111000
11111000
11111010
11111000
11111101
11111111
11111111
NAME OuterWorld (2,15)

TIL ja
01000000
10001010
00100000
10001001
00100000
01010111
10111010
11101111
NAME OuterWorld (3,15)

TIL jb
00100100
10001000
00100001
00000100
01010001
01001010
11110110
10111111
NAME OuterWorld (4,15)

TIL jc
01001001
00010000
01000101
00000000
00101001
10100101
11011110
11110111
NAME OuterWorld (5,15)

TIL jd
00000010
01010000
00000101
01010000
00000010
01011010
11101101
10111011
NAME OuterWorld (6,15)

TIL je
00000010
01001000
00010001
01000100
00000001
11011101
01101011
11111110
NAME OuterWorld (7,15)

TIL jf
10101010
00000000
01001010
00010000
00000010
01101010
10111101
11101111
NAME OuterWorld (8,15)

TIL jg
10010010
00001000
10100001
00001000
01000010
10101010
10111101
11101111
NAME OuterWorld (9,15)

TIL jh
10010000
00100100
00000001
10101000
00000010
10101010
11111101
01010111
NAME OuterWorld (10,15)

TIL ji
10000011
00010101
00000011
01010000
00000101
11010111
10111011
11101111
NAME OuterWorld (11,15)

TIL jj
11010010
11000000
10010100
11000001
11001000
11010110
11101011
11111111
NAME OuterWorld (13,15)

TIL jk
01000101
10000000
00101010
00000000
10010100
10101010
01101101
11111011
NAME OuterWorld (14,15)

TIL jl
01011111
00001111
10101111
00011111
10001111
10111111
11011111
01111111
NAME OuterWorld (15,15)

TIL jn
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000
NAME Cliff (1,0)

TIL jo
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000111
NAME Cliff (4,0)

TIL jp
00000000
00000000
00000000
00000000
00000000
00000000
00011111
11100101
NAME Cliff (5,0)

TIL jq
00000000
00000000
00000000
00000000
00000000
00010011
11111100
01000000
NAME Cliff (6,0)

TIL jr
00000000
00000000
00000000
00000000
00000000
11111111
10101010
00000000
NAME Cliff (7,0)

TIL js
00000000
00000000
00000000
00000000
00000000
11111111
10101000
00000000
NAME Cliff (8,0)

TIL jt
00000000
00000000
00000000
00000000
00000000
10010010
01111000
00000000
NAME Cliff (9,0)

TIL ju
00000000
00000000
00000000
00000000
00000000
01111111
00101010
00000000
NAME Cliff (10,0)

TIL jv
00000000
00000000
00000000
00000000
00000000
11111111
01001001
00000000
NAME Cliff (11,0)

TIL jw
00000000
00000000
00000000
00000000
00000000
11111111
00100101
00000000
NAME Cliff (12,0)

TIL jx
00000000
00000000
00111111
11100010
11100000
11100000
00000000
00000000
NAME Cliff (13,0)

TIL jy
00000000
00000000
11110000
00011111
00000100
00000000
00000000
00000000
NAME Cliff (14,0)

TIL jz
00000000
00000000
00000000
11111111
10101001
00000000
00000000
00000000
NAME Cliff (15,0)

TIL k0
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001000
NAME Cliff (1,1)

TIL k1
00011101
00110000
00111100
00010111
00000001
00000111
00001111
00011111
NAME Cliff (4,1)

TIL k2
00000000
00000000
00000000
11111100
11111101
11111100
11111110
11111111
NAME Cliff (5,1)

TIL k3
00000000
00000000
00000000
00000000
11111111
10101010
00000000
00000000
NAME Cliff (6,1)

TIL k4
00000000
00000000
00000000
00000000
11111111
10101010
00000000
00000111
NAME Cliff (9,1)

TIL k5
00000000
00000000
00000000
00000000
11111111
10101010
00000000
11111111
NAME Cliff (10,1)

TIL k6
00000000
00000000
00000000
00111111
11001010
00000000
01111111
11101000
NAME Cliff (11,1)

TIL k7
00000000
00000000
00000000
10000000
01000000
11000000
10000000
00000000
NAME Cliff (12,1)

TIL k8
00000000
00000000
00000000
00000000
00000000
00001000
00000000
00000000
NAME Cliff (13,1)

TIL k9
00000000
00000000
00000000
00000000
00110000
00000000
00000000
00000000
NAME Cliff (15,1)

TIL ka
00000000
00000000
00000000
00000000
00000000
00000000
00100000
00000000
NAME Cliff (3,2)

TIL kb
00111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME Cliff (4,2)

TIL kc
10000000
11000000
11000001
11000111
11101100
11001000
11100110
11000011
NAME Cliff (6,2)

TIL kd
00000000
00000111
11111110
11010000
00000000
00000000
00000000
11111111
NAME Cliff (7,2)

TIL ke
00111111
11111111
00000000
00000000
00000000
00000000
00000000
11110100
NAME Cliff (8,2)

TIL kf
11111010
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (9,2)

TIL kg
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (10,2)

TIL kh
10000000
11000000
11111110
00101111
00000000
00000000
00000000
00000001
NAME Cliff (11,2)

TIL ki
00000000
00000000
00000000
11111111
00100100
00000000
00000000
00000000
NAME Cliff (12,2)

TIL kj
00000000
00000000
00000000
11111111
10101010
00000000
00000000
00000000
NAME Cliff (13,2)

TIL kk
00000000
00000000
11111100
11111111
00000001
00000000
00000000
00000000
NAME Cliff (14,2)

TIL kl
00000000
00000000
00000000
11111111
01001111
00000000
00000000
00000000
NAME Cliff (15,2)

TIL km
01111111
01111111
00111111
00011111
00011111
00000111
00000001
00000000
NAME Cliff (4,3)

TIL kn
11111111
11111111
11111111
11111111
11111111
11111100
01010000
00000000
NAME Cliff (5,3)

TIL ko
11000010
11000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME Cliff (6,3)

TIL kp
00011111
00000000
00000000
00000000
00000001
00000000
00000000
00000000
NAME Cliff (7,3)

TIL kq
11111111
00010010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (8,3)

TIL kr
11111111
01001001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (9,3)

TIL ks
11111111
01010101
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (10,3)

TIL kt
11110101
01111111
00001001
00000000
00000000
00000000
00000000
00000000
NAME Cliff (11,3)

TIL ku
00000000
11111111
00100011
00000000
00000000
00000000
00000000
00000000
NAME Cliff (12,3)

TIL kv
00000000
10010000
11111110
10010111
00000011
00001111
00110100
01110000
NAME Cliff (13,3)

TIL kw
10000000
01111111
00011101
00000000
00000000
00000000
00000000
00000000
NAME Cliff (0,4)

TIL kx
00000000
00000000
11111111
00101011
00000000
00000000
00000000
00000000
NAME Cliff (1,4)

TIL ky
00000000
00000000
11111110
11111101
00000000
00000000
00000000
00000000
NAME Cliff (2,4)

TIL kz
00000000
00000000
00000000
11111111
00010010
00000000
00000000
00000000
NAME Cliff (3,4)

TIL l0
00000000
00000000
00111111
11111111
00000000
00000000
00000000
00000000
NAME Cliff (4,4)

TIL l1
00000000
00000001
11111110
11010000
00000111
00111110
01110000
01111111
NAME Cliff (5,4)

TIL l2
00000000
11100000
00110000
11110000
11100000
00000000
00000000
11111000
NAME Cliff (6,4)

TIL l3
00000000
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (10,4)

TIL l4
01100000
01111111
00001010
00000000
00000000
00000000
00000000
00000000
NAME Cliff (13,4)

TIL l5
00000000
11111111
10101010
00000000
00000000
00000000
00000000
00000000
NAME Cliff (14,4)

TIL l6
00000000
01000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (1,5)

TIL l7
00000001
00000111
00001100
00001100
00000111
00000010
00000000
00000011
NAME Cliff (2,5)

TIL l8
11111111
11111111
00000000
00000000
11100000
01110000
00110000
11110000
NAME Cliff (3,5)

TIL l9
00000000
11111111
01010011
00000000
00000000
00000000
00000000
00000001
NAME Cliff (4,5)

TIL la
00111111
11111111
11111100
01000000
00000000
00000011
00011111
11111010
NAME Cliff (5,5)

TIL lb
11111111
11111111
10101010
00000000
00001111
11111100
10100000
00000000
NAME Cliff (6,5)

TIL lc
11111111
11111111
10101100
11111111
11111100
10000000
00000000
00000000
NAME Cliff (7,5)

TIL ld
00000000
11000000
01100000
11000000
10000000
00000000
00000000
00000000
NAME Cliff (8,5)

TIL le
00000000
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (9,5)

TIL lf
00010000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Cliff (12,5)

TIL lg
00000000
00000000
00000011
00000000
00000000
00000000
00000000
00000000
NAME Cliff (13,5)

TIL lh
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000000
NAME Cliff (14,5)

TIL li
00000000
11111111
01010101
00000000
00000000
00000000
00011111
11110101
NAME Cliff (0,6)

TIL lj
10101111
11100100
00000000
00000000
00000001
01111111
10101000
00000000
NAME Cliff (1,6)

TIL lk
11111111
10101000
00000001
00001111
11110100
01000000
00000000
00000000
NAME Cliff (2,6)

TIL ll
00000000
00010111
11111101
01010000
00000000
00000000
00000000
00000000
NAME Cliff (3,6)

TIL lm
01101111
11111010
00100000
00000000
00000000
00000000
00000010
00000000
NAME Cliff (4,6)

TIL ln
00000000
00000000
00000000
00000000
10000000
10000000
00000000
00000000
NAME Cliff (12,6)

TIL lo
00000000
00000000
00000000
00000000
00000000
00000001
00000000
00000000
NAME Cliff (0,7)

TIL lp
00000000
00000000
00000010
00000000
00000000
00000000
00000000
00000000
NAME Cliff (2,7)

TIL lq
00000000
00000000
00000000
00000000
00000000
00000011
00000011
00000111
NAME Cliff (4,7)

TIL lr
00000000
00000000
00000000
00000111
01111111
11111111
11111111
11111111
NAME Cliff (5,7)

TIL ls
00000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME Cliff (6,7)

TIL lt
00000000
00000000
00000111
11111111
11111111
11111111
11111111
11111111
NAME Cliff (7,7)

TIL lu
00000000
11111000
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cliff (8,7)

TIL lv
00000000
00000000
11100000
11111000
11111000
11110000
11111110
11111111
NAME Cliff (9,7)

TIL lw
00000000
00000000
00000000
00000000
00000000
00011111
00011100
11111111
NAME Cliff (10,7)

TIL lx
00000000
00000000
00000000
00000000
00001111
11111111
10010111
00000111
NAME Cliff (11,7)

TIL ly
00000000
00000000
00000000
00000011
11111111
11100000
00000000
10000000
NAME Cliff (12,7)

TIL lz
00000000
00000000
00010000
11111111
11001010
00000000
00000000
00000000
NAME Cliff (13,7)

TIL m0
00000000
00000000
01111111
11111010
00000000
00000000
00000000
00000000
NAME Cliff (15,7)

TIL m1
00000000
00000000
00000000
00000000
00000000
00000100
00000100
00000000
NAME Cliff (3,8)

TIL m2
00000111
00000110
00000100
00000010
00000011
00000001
00000001
00000001
NAME Cliff (4,8)

TIL m3
11111111
11111111
01111111
00111111
00001111
00000011
01010100
01010000
NAME Cliff (5,8)

TIL m4
11111011
11110000
11111000
11110000
11110000
11111111
11111111
11111111
NAME Cliff (10,8)

TIL m5
11111001
10111111
00000010
00000000
00000000
11000000
11100000
11110000
NAME Cliff (11,8)

TIL m6
11111111
11110101
11111100
01000111
00000101
00000011
00001111
00011100
NAME Cliff (12,8)

TIL m7
11100000
11111100
00001110
00000010
00000111
00111100
01110100
01100000
NAME Cliff (13,8)

TIL m8
00000000
00000001
00000001
00000000
00000000
00000000
00000000
00000000
NAME Cliff (14,8)

TIL m9
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00000000
NAME Cliff (1,9)

TIL ma
00000001
00000001
00000001
00000001
00000001
00000000
00000000
00000000
NAME Cliff (4,9)

TIL mb
01000011
01001111
01011111
01111111
11001111
10101111
11100011
01100001
NAME Cliff (5,9)

TIL mc
11111000
11111000
11111000
11111000
11111100
11111110
11111111
11111110
NAME Cliff (11,9)

TIL md
00110000
00111000
00001111
00000001
00000000
00000000
00000000
00001000
NAME Cliff (12,9)

TIL me
00111000
00101111
11110101
01011111
00000101
00000000
00000000
00000000
NAME Cliff (13,9)

TIL mf
00000000
11100000
00011111
10010101
01111110
00101101
00000000
00000000
NAME Cliff (14,9)

TIL mg
00000000
00000000
11111000
10101100
00000110
11110110
01011010
00011110
NAME Cliff (15,9)

TIL mh
01100001
00100001
00100001
00110011
00100011
01100111
01000111
10001111
NAME Cliff (5,10)

TIL mi
11111100
11111100
11111000
11101100
11111100
11011100
11110000
11111110
NAME Cliff (11,10)

TIL mj
00000000
00000000
10000000
10000000
00000000
00000000
00000000
00000000
NAME Cliff (14,10)

TIL mk
00111110
01111100
01111111
00111110
00000000
00000000
00000000
00000000
NAME Cliff (15,10)

TIL ml
00000000
00000000
00000001
00000000
00000001
00000001
00000001
00000011
NAME Cliff (4,11)

TIL mm
11011111
10111111
10111111
11111111
11111111
01111111
11111111
01011111
NAME Cliff (5,11)

TIL mn
00000000
11000000
11110000
11111100
11111110
11111111
11111111
11111111
NAME Cliff (12,11)

TIL mo
00000010
00000010
00000010
00000110
00001111
00001111
00011111
01111111
NAME Cliff (4,12)

TIL mp
01001101
01100011
11000001
10000111
01111111
11111111
11111111
11111111
NAME Cliff (5,12)

TIL mq
11111110
11111100
11111100
11111100
11111100
11111110
11111111
11111111
NAME Cliff (12,12)

TIL mr
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME Cliff (13,12)

TIL ms
00000011
00000011
00001111
00001111
00011111
00111111
00111111
00111111
NAME Cliff (3,13)

TIL mt
11000000
11100000
11111000
11111100
11111110
11111111
11111111
11111111
NAME Cliff (13,13)

TIL mu
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11000000
NAME Cliff (14,13)

TIL mv
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001111
NAME Cliff (1,14)

TIL mw
00000000
00000000
00000000
00000000
00000011
00011111
11111111
11111111
NAME Cliff (2,14)

TIL mx
01111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cliff (3,14)

TIL my
11110000
11111000
11111100
11111111
11111111
11111111
11111111
11111111
NAME Cliff (14,14)

TIL mz
00000000
00000000
00000000
00000000
00000000
11000000
11100000
11111100
NAME Cliff (15,14)

TIL n0
00000000
00000000
00000000
00000001
00000111
00111111
11111111
11111111
NAME Cliff (0,15)

TIL n1
00111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cliff (1,15)

TIL jm
11111111
11111111
11111111
11111111
11111111
11111111
11010111
01001111
NAME Bedroom (7,1)

TIL n2
11111111
11111111
11111111
11111111
11111101
11110100
10100000
10001000
NAME Bedroom (5,2)

TIL n3
11111011
11101000
11101000
00100001
00000000
00001000
10000010
00100000
NAME Bedroom (6,2)

TIL n4
00011011
00001101
00101111
00010101
00011101
10001011
00011110
00010101
NAME Bedroom (7,2)

TIL n5
11111111
01101111
10111111
01101111
10110101
11011110
10110101
11101111
NAME Bedroom (8,2)

TIL n6
11111111
11111111
11111111
11111111
11111111
11011111
01111111
10101011
NAME Bedroom (9,2)

TIL n7
11111111
11111111
11111111
11111110
11111110
11110001
11010111
01001111
NAME Bedroom (3,3)

TIL n8
11111100
11110101
11010000
10001111
01111100
11000010
00001000
00101000
NAME Bedroom (4,3)

TIL n9
00000010
00100000
00001000
00100001
11000000
00111000
00001010
11000110
NAME Bedroom (5,3)

TIL na
00000100
10010000
00000000
00001001
00011000
11100111
10000000
00000000
NAME Bedroom (6,3)

TIL nb
10011110
00001011
01011101
00001011
00011110
00101011
10010110
11001101
NAME Bedroom (7,3)

TIL nc
10111010
11011101
01010111
00011010
01100111
00111000
10011001
01111011
NAME Bedroom (8,3)

TIL nd
11110110
10101111
01111010
11010111
10111011
11011101
01101011
00101110
NAME Bedroom (9,3)

TIL ne
11111111
11111111
10110111
01011111
11101010
01011111
10110101
11111110
NAME Bedroom (10,3)

TIL nf
11111111
11111111
11111111
11111111
11111111
01111111
10111111
11010111
NAME Bedroom (11,3)

TIL ng
11111101
11110000
11111101
11111010
11111001
11111010
11111001
11111010
NAME Bedroom (2,4)

TIL nh
00111000
11000000
00000000
00000000
00000000
10000000
00001010
00010000
NAME Bedroom (3,4)

TIL ni
11000011
00011001
01001111
00011111
00011111
10011111
00101110
10010111
NAME Bedroom (4,4)

TIL nj
01101100
11110100
11101100
11100100
11111100
11110100
11100000
10000011
NAME Bedroom (5,4)

TIL nk
00000000
00000000
00000000
00000000
00000111
00011101
01100111
00000001
NAME Bedroom (6,4)

TIL nl
00111111
00111010
11001111
10010101
00011110
10001011
00011101
10001011
NAME Bedroom (7,4)

TIL nm
00011011
01111000
00111001
01011011
01111011
00111011
01011011
00110001
NAME Bedroom (8,4)

TIL nn
11000101
11111001
11111010
11111000
11110000
11100000
11000000
11000001
NAME Bedroom (9,4)

TIL no
10101011
01110110
01011101
00101011
00001101
00010010
01111000
11111011
NAME Bedroom (10,4)

TIL np
11111011
10101101
11011011
01110110
10101111
11111010
01010111
10011011
NAME Bedroom (11,4)

TIL nq
01111111
11111111
01111111
11111111
01111111
11111111
01111111
11111111
NAME Bedroom (12,4)

TIL nr
11111001
11111011
11111001
11111111
11111100
11111001
11111001
11111000
NAME Bedroom (2,5)

TIL ns
00000100
00010010
00000001
10101011
01100100
10011000
10000100
11110001
NAME Bedroom (3,5)

TIL nt
01011110
01010100
01110000
10000001
00001110
00110000
11010000
10000000
NAME Bedroom (4,5)

TIL nu
00001001
00001100
01110000
10000001
00000110
00001100
00100101
00000101
NAME Bedroom (5,5)

TIL nv
00001010
00101100
01110000
10000000
00100100
10010000
01001001
10100100
NAME Bedroom (6,5)

TIL nw
10011101
10001111
10010101
10011011
10001101
10010111
10011101
10001011
NAME Bedroom (7,5)

TIL nx
01011011
00111011
01011011
00111011
00011011
01101011
00101001
00111000
NAME Bedroom (8,5)

TIL ny
11000001
11000001
11000001
10000000
11100000
10110000
10111001
11111011
NAME Bedroom (9,5)

TIL nz
11111011
11111011
11110011
00111011
00001011
00111001
01111001
11111000
NAME Bedroom (10,5)

TIL o0
11100101
11100011
11100010
11110011
11111010
11111011
11110010
11111011
NAME Bedroom (11,5)

TIL o1
01111111
01111111
11111111
11111111
10111111
11111111
11111111
01111111
NAME Bedroom (12,5)

TIL o2
11111000
11111011
11111001
11111010
11111000
11111000
11111010
11111000
NAME Bedroom (2,6)

TIL o3
10111110
01000000
10000000
00000000
00000000
10001001
00000000
00100000
NAME Bedroom (3,6)

TIL o4
00000000
01000000
00000010
00000000
00001000
00100001
00000000
10000100
NAME Bedroom (4,6)

TIL o5
10001101
00100101
00000101
10001100
00000101
00100101
00001101
00100101
NAME Bedroom (5,6)

TIL o6
00010110
00011100
11001100
10100100
01000110
00000100
10011100
10000100
NAME Bedroom (6,6)

TIL o7
10011101
10001111
10010101
10011011
10001110
10011011
10010110
10011011
NAME Bedroom (7,6)

TIL o8
01011011
00111011
01011011
00110011
10110011
00111001
01011011
01111011
NAME Bedroom (8,6)

TIL o9
00110011
11000011
11111001
11111011
11110010
11100011
11110011
11111011
NAME Bedroom (9,6)

TIL oa
11111011
11111011
11111011
01111011
11111011
10001011
11110011
11111000
NAME Bedroom (10,6)

TIL ob
11111011
11110011
11011010
11010011
11111011
11111010
11110011
01111010
NAME Bedroom (11,6)

TIL oc
01111111
11111111
10111111
01111111
11111111
11111111
01111111
11111111
NAME Bedroom (12,6)

TIL od
11111000
11111000
11111010
11111000
11111001
11111000
11111001
11111000
NAME Bedroom (2,7)

TIL oe
10000100
00000000
00100100
00000001
00100000
00001000
00000001
01000101
NAME Bedroom (3,7)

TIL of
00010000
01000000
00000010
00011100
01100011
10000000
00000000
00000000
NAME Bedroom (4,7)

TIL og
10000100
00001101
00100101
10000101
00001100
10000100
01001010
01000111
NAME Bedroom (5,7)

TIL oh
10100110
00110000
01011000
10100111
00011000
11000000
01000001
00010000
NAME Bedroom (6,7)

TIL oi
10001101
10010111
10011101
00010110
00011011
01001101
00010111
00011010
NAME Bedroom (7,7)

TIL oj
00111011
00011011
00111010
10000011
01111000
00110011
00110011
10111011
NAME Bedroom (8,7)

TIL ok
11111011
01111011
01110011
11100011
11111011
00111011
11010011
11000011
NAME Bedroom (9,7)

TIL ol
00111011
01111011
11110011
11111011
11111011
11111011
11111011
11111011
NAME Bedroom (10,7)

TIL om
10011011
10110011
11100010
11111011
11111011
11110010
11111011
11111010
NAME Bedroom (11,7)

TIL on
11111010
11111000
11111001
11111000
11111010
11111000
11111000
11111010
NAME Bedroom (2,8)

TIL oo
00000001
00100001
00001001
00000000
01000100
00010000
10000011
00011100
NAME Bedroom (3,8)

TIL op
00000000
00000000
00000000
10000000
10000000
01100011
00011100
00000000
NAME Bedroom (4,8)

TIL oq
01000000
01000000
01111001
00010110
10000010
00000001
00000001
00000001
NAME Bedroom (5,8)

TIL or
00000100
00100000
00000010
00001000
00100000
00000001
00001000
10000000
NAME Bedroom (6,8)

TIL os
00001111
10011010
00010111
00011010
01001111
00010101
00011110
01001011
NAME Bedroom (7,8)

TIL ot
00111011
10111011
00110001
01011011
00111011
00010011
11100001
10111000
NAME Bedroom (8,8)

TIL ou
11100001
11111010
11111001
11100011
11100011
11111011
11110011
10111011
NAME Bedroom (9,8)

TIL ov
11111011
01111000
11001011
11110011
11111010
11111000
10011011
11111011
NAME Bedroom (10,8)

TIL ow
11110011
11111011
11111010
11110011
11111011
01111010
00010011
11101010
NAME Bedroom (11,8)

TIL ox
11111000
11111000
11111010
11111000
11111000
11111010
11111000
11111000
NAME Bedroom (2,9)

TIL oy
00100000
10110000
00101000
00110000
00101101
00110101
10110101
00101010
NAME Bedroom (3,9)

TIL oz
00000000
00000000
00000001
00000000
00000100
00000001
00010100
00000010
NAME Bedroom (4,9)

TIL p0
00010101
00000001
00000001
00101101
00100001
01000001
00001001
10000001
NAME Bedroom (5,9)

TIL p1
00100100
00000001
00001000
10000000
00010010
00000000
10000001
00000001
NAME Bedroom (6,9)

TIL p2
00010110
00011011
00010110
01001111
00001001
01101111
00110110
10101110
NAME Bedroom (7,9)

TIL p3
11101111
01110101
11010101
01011111
01110000
10000000
00000000
00000000
NAME Bedroom (8,9)

TIL p4
00110011
01010111
10100001
10101001
01110110
00011111
00000010
00000001
NAME Bedroom (9,9)

TIL p5
11111011
11111011
11111011
11111011
00101011
10011011
11010001
01101010
NAME Bedroom (10,9)

TIL p6
11110011
11111011
11111010
11110011
11111011
11111010
01110011
11111011
NAME Bedroom (11,9)

TIL p7
01111111
11111111
10111111
01111111
11111111
11111111
01111111
01111111
NAME Bedroom (12,9)

TIL p8
11111010
11111000
11111001
11111000
11111010
11111000
11111001
11111000
NAME Bedroom (2,10)

TIL p9
00110101
00110101
00101010
00110101
00110110
00110101
00101010
00110101
NAME Bedroom (3,10)

TIL pa
01011000
01000000
10000000
00000100
00010000
00000001
10000101
00101000
NAME Bedroom (4,10)

TIL pb
00010011
00000001
00001011
01010001
10010001
01000001
00000111
00000100
NAME Bedroom (5,10)

TIL pc
00001110
00110011
11001110
01011000
11101001
11100000
00000010
00001000
NAME Bedroom (6,10)

TIL pd
10111000
11000000
00010000
00000101
01000000
00010010
00000000
10010010
NAME Bedroom (7,10)

TIL pe
00000000
00000000
00000000
00000000
01000000
00010000
01000010
00001000
NAME Bedroom (8,10)

TIL pg
11101100
00011011
00000110
00000111
00000101
00000110
00000101
00000111
NAME Bedroom (10,10)

TIL ph
01101010
10010011
11000101
01111011
10101101
11110111
10111011
01101101
NAME Bedroom (11,10)

TIL pi
11111111
11111111
01111111
11111111
01111111
01111111
11111111
01111111
NAME Bedroom (12,10)

TIL pj
11111010
11111000
11111001
11111000
11111010
11111000
11111001
11110101
NAME Bedroom (2,11)

TIL pk
00110101
00101010
00110101
00110101
00101010
01110101
01010110
10101110
NAME Bedroom (3,11)

TIL pl
01000000
10000010
00001000
00000000
00100010
00001011
10101101
00110110
NAME Bedroom (4,11)

TIL pm
00011100
00011010
00011111
01011101
11110101
10011110
01101111
10110101
NAME Bedroom (5,11)

TIL pn
10000000
00100100
10000000
11101010
01111000
11011111
11101011
01011101
NAME Bedroom (6,11)

TIL po
00000000
10101000
00000010
01000000
00010010
01000000
01000011
11010110
NAME Bedroom (7,11)

TIL pp
10000000
00100100
00000001
10000110
00011111
11110101
01011110
11101011
NAME Bedroom (8,11)

TIL pq
00110100
11011000
10110101
11011010
01110111
10101101
11011011
01101110
NAME Bedroom (9,11)

TIL pr
00111110
10111011
11011101
11011110
01000010
00111001
11001010
10110101
NAME Bedroom (10,11)

TIL ps
11011011
01110110
10111011
10010110
11101011
00101101
10101010
01001011
NAME Bedroom (11,11)

TIL pt
11111111
10111111
11111111
11111111
01111111
01111111
11111111
00111111
NAME Bedroom (12,11)

TIL pu
11111010
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Bedroom (2,12)

TIL pv
10110010
01010101
10010110
11101001
11111101
11111010
11111111
11111111
NAME Bedroom (3,12)

TIL pw
10101010
11010101
01010100
10101010
00100101
11010101
10101010
11101001
NAME Bedroom (4,12)

TIL px
10011111
01001000
00101011
11010101
01010100
00101010
10010101
01001010
NAME Bedroom (5,12)

TIL py
10110011
11101110
01011011
01010110
10101010
01010101
01001011
10101000
NAME Bedroom (6,12)

TIL pz
01111011
11011101
10101010
11111101
11010111
01111010
01111101
10110101
NAME Bedroom (7,12)

TIL q0
01010101
11011110
10110101
11101010
00101011
11010110
01010011
00101011
NAME Bedroom (8,12)

TIL q1
10110110
10011010
01101011
11101100
10010101
01011010
01110101
11001101
NAME Bedroom (9,12)

TIL q2
11010100
10010101
11010100
01010101
10101010
10101010
01010111
01011111
NAME Bedroom (10,12)

TIL q3
10100101
01010101
10101101
01011111
10111111
11111111
11111111
11111111
NAME Bedroom (11,12)

TIL q4
11111111
11111111
11101111
11111111
11111111
11111111
11111111
11111111
NAME Bedroom (12,12)

TIL q5
11111101
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Bedroom (4,13)

TIL q6
01010101
10101010
10100101
11010100
11111010
11111111
11111111
11111111
NAME Bedroom (5,13)

TIL q7
01010101
10101010
01010101
10101010
01010101
01001010
10100101
11110010
NAME Bedroom (6,13)

TIL q8
01010101
10101010
00100101
10010100
01010010
10101010
01010101
10101010
NAME Bedroom (7,13)

TIL q9
01010100
10101010
01010101
10101010
10010010
01010101
01010111
10101111
NAME Bedroom (8,13)

TIL qa
10110010
10101101
01010111
10111111
11011111
11111111
11111111
11111111
NAME Bedroom (9,13)

TIL qb
11111111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Bedroom (10,13)

TIL qc
11111010
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Bedroom (6,14)

TIL qd
01010101
10001010
11010111
11101111
11111111
11111111
11111111
11111111
NAME Bedroom (7,14)

TIL qe
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Bedroom (8,14)

TIL pf
11111111
11111111
11111111
11111111
11111111
11111011
11111111
11111111
NAME Forest (1,0)

TIL qf
11111111
11111111
11111111
11111011
11111111
11111111
11111111
11111011
NAME Forest (2,0)

TIL qg
11110111
11111111
11111111
11111111
11111111
10110110
11111011
11101101
NAME Forest (4,0)

TIL qh
11111111
11111111
11111111
11111111
11110110
11111111
11001010
00101111
NAME Forest (5,0)

TIL qi
11111011
11111111
11111011
11011111
11111011
10111110
01101111
01111001
NAME Forest (6,0)

TIL qj
01101101
11011111
11111101
01101111
11110110
11011111
11110101
01011111
NAME Forest (7,0)

TIL qk
10101010
11011111
01111011
11011111
11110101
10011111
11111010
01011010
NAME Forest (8,0)

TIL ql
11101010
10011111
01101011
11111110
01011011
11101110
11011011
11111111
NAME Forest (9,0)

TIL qm
11111111
10111111
11101111
11101011
10111011
11110101
11111111
01101011
NAME Forest (10,0)

TIL qn
11111111
11111111
11111111
11111111
01111101
11111111
11011111
11110111
NAME Forest (11,0)

TIL qo
11111111
11111111
11111111
11011011
11111110
01100110
11110111
11111111
NAME Forest (12,0)

TIL qp
11111111
11111111
11111111
10111111
00111111
10111111
11111011
11011111
NAME Forest (13,0)

TIL qq
11111111
11111111
11111111
11111111
11110111
01011110
11111111
11110011
NAME Forest (14,0)

TIL qr
11111111
11111111
11111111
11111111
11101111
11111111
11110111
11101111
NAME Forest (15,0)

TIL qs
11111101
11110101
11111111
11111111
11111111
11111111
11111011
11110111
NAME Forest (0,1)

TIL qt
11111111
11111111
11011101
11110111
11001101
11111101
11101111
11101101
NAME Forest (1,1)

TIL qu
10111111
11111111
11110111
11111110
10111100
11101011
01111111
11101110
NAME Forest (2,1)

TIL qv
11101111
11001011
01111101
01101111
10111101
11110111
11011110
01101101
NAME Forest (3,1)

TIL qw
01111001
11110111
11110110
11111111
10101011
11111111
11011010
11111110
NAME Forest (4,1)

TIL qx
11111101
01101111
11111010
11011111
00110110
11101111
10011010
11011111
NAME Forest (5,1)

TIL qy
10101111
11111101
11011011
11111010
10101111
10111010
11111101
11001001
NAME Forest (6,1)

TIL qz
11111011
10111111
11101101
11011110
11110101
10111101
11101110
10111011
NAME Forest (7,1)

TIL r0
00111010
11110101
10110001
11110100
10101000
11101010
10101010
11010110
NAME Forest (8,1)

TIL r1
01010101
11111111
00101101
00111111
01001011
00101110
00011111
10101010
NAME Forest (9,1)

TIL r2
11111101
10101100
11111111
01101010
11011101
11100110
10101011
11111000
NAME Forest (10,1)

TIL r3
11011111
10011110
11110111
11101001
00100011
01100001
00000011
10111010
NAME Forest (11,1)

TIL r4
10110011
11101111
10110010
11111110
01101011
11111111
10110011
11110000
NAME Forest (12,1)

TIL r5
01111011
10101111
11110011
11101110
11101101
11101111
00110111
01111110
NAME Forest (13,1)

TIL r6
11011111
01101010
11101000
10100011
11001011
10101011
11110111
11101111
NAME Forest (14,1)

TIL r7
10011101
01111111
10000111
10111111
11110111
01101111
10111111
11111111
NAME Forest (15,1)

TIL r8
11011111
11101111
11101111
11101101
11111111
11011110
11110111
01111101
NAME Forest (0,2)

TIL r9
11001011
11110001
01100011
10001111
10101111
11100101
01100000
00000110
NAME Forest (1,2)

TIL ra
10011010
11100111
11001101
10101111
10111000
11010010
11010010
11010101
NAME Forest (2,2)

TIL rb
10111111
01110111
11011101
11110111
01011110
00110111
00111101
01101111
NAME Forest (3,2)

TIL rc
01100110
11010101
01111111
11101010
11011111
11110000
01100100
11000100
NAME Forest (4,2)

TIL rd
01110110
10001001
01101110
10101100
11010010
01101110
00101001
00110101
NAME Forest (5,2)

TIL re
10011111
10001101
00011111
10000101
10011111
00101101
01111011
01001110
NAME Forest (6,2)

TIL rf
11111110
01010110
11111101
10110111
11111111
01010110
11111111
11011001
NAME Forest (7,2)

TIL rg
11110110
11010100
11110100
01101100
01101000
00110010
01110100
11010000
NAME Forest (8,2)

TIL rh
00011111
11101101
10010111
01011110
00101111
00011010
00101111
00101101
NAME Forest (9,2)

TIL ri
11101100
10111101
11100111
10111101
11101010
11101101
10101101
11110101
NAME Forest (10,2)

TIL rj
11010011
00000011
00000010
10000001
11100011
00110001
01001111
01001011
NAME Forest (11,2)

TIL rk
11110000
11011000
11111101
11011111
11111111
01110101
11101110
01111110
NAME Forest (12,2)

TIL rl
01110111
11111111
11111111
11111111
11110111
11111111
11111111
10111011
NAME Forest (13,2)

TIL rm
11111110
11111111
11111011
11111111
11111111
11101111
01010111
11011111
NAME Forest (14,2)

TIL rn
11111111
11111111
11111111
10111111
11111111
11011111
01111111
11111111
NAME Forest (15,2)

TIL ro
10101101
01101010
01001010
11110111
11010101
11111011
11001011
00000110
NAME Forest (0,3)

TIL rp
00000101
10011111
10010100
10101101
10011111
11110111
01011100
11110111
NAME Forest (1,3)

TIL rq
11001011
00111111
11101011
11111110
10110111
11111101
10101111
01111101
NAME Forest (2,3)

TIL rr
11111011
01011110
11110111
11011101
11110111
01111111
11011011
11101111
NAME Forest (3,3)

TIL rs
01000001
11100000
11000000
10100001
11111110
10111010
11111010
01111111
NAME Forest (4,3)

TIL rt
01010101
01011010
00110110
00101010
00010000
00101001
00010000
11111100
NAME Forest (5,3)

TIL ru
01111001
00111111
01101101
11111111
10101101
01101111
00101010
11111111
NAME Forest (6,3)

TIL rv
11110111
01111110
11010111
11111101
01011111
11110110
11011111
11111111
NAME Forest (7,3)

TIL rw
11101100
10110000
01100000
10111110
11101101
11011111
10111010
11111110
NAME Forest (8,3)

TIL rx
00001111
00000111
00001101
00000111
00001110
00101011
00001111
11101111
NAME Forest (9,3)

TIL ry
01011111
11100110
01101111
11000101
11100010
11100100
01100011
11111111
NAME Forest (10,3)

TIL rz
10110011
11000101
10000011
00000111
00010001
00000111
00010001
11011011
NAME Forest (11,3)

TIL s0
11010100
01110010
11010000
01110000
11100000
10110000
11100000
11111111
NAME Forest (12,3)

TIL s1
10111110
00000111
00001110
00000111
00001011
00001111
01111111
11111110
NAME Forest (13,3)

TIL s2
11111110
10111110
11011010
10110000
11110001
10101110
11101011
10100101
NAME Forest (14,3)

TIL s3
11111111
11111111
01101111
11111111
00110111
11111101
00011010
11001010
NAME Forest (15,3)

TIL s4
11000001
01100110
00000101
00000011
10000111
10011001
01100111
11101111
NAME Forest (0,4)

TIL s5
00000101
00001111
01000111
10001111
01111111
01111111
11111111
10111111
NAME Forest (1,4)

TIL s6
11111110
11011111
11111111
11111111
11111111
11101101
11111111
11111111
NAME Forest (2,4)

TIL s7
10111111
11110110
10111101
11111111
10111011
11111111
11110110
01111111
NAME Forest (3,4)

TIL s8
11010101
11111111
11111111
10100000
01000000
10000010
11000111
10100000
NAME Forest (4,4)

TIL s9
01101111
11111101
11111111
00000000
00000000
10101010
11111111
00100011
NAME Forest (5,4)

TIL sa
01111011
11111111
11101110
00000000
00000000
10001010
11111111
00100001
NAME Forest (6,4)

TIL sb
11111110
11110111
10111110
00000000
00000000
10100001
11111111
11111010
NAME Forest (7,4)

TIL sc
11111111
11101110
11111011
00000000
00000000
01010101
11111111
10001010
NAME Forest (8,4)

TIL sd
11111111
11111011
10111110
00000000
00000000
01010101
11111111
10001111
NAME Forest (9,4)

TIL se
11111110
10110111
11111111
00000000
00000000
01001010
11111111
11100000
NAME Forest (10,4)

TIL sf
11111111
11111111
01101101
00000000
00000000
10101010
11111111
01000111
NAME Forest (11,4)

TIL sg
11011010
01111111
11111111
00000000
00000000
10101010
11111111
11110000
NAME Forest (12,4)

TIL sh
10110111
11111110
11100101
00100111
00000110
10000011
00000011
10000111
NAME Forest (13,4)

TIL si
11100011
11000101
11100001
10100000
11110001
11010000
01110100
11011100
NAME Forest (14,4)

TIL sj
11100001
10110110
11110100
10101010
01110101
00001110
00001010
10000101
NAME Forest (15,4)

TIL sk
11101111
10111111
11111111
11111111
10111111
11110110
00111101
11100101
NAME Forest (0,5)

TIL sl
11111111
11111111
11111101
10111111
11111111
11101111
10101111
11000011
NAME Forest (1,5)

TIL sm
11111111
11111101
11111101
11111111
11111011
11111011
11000001
11000010
NAME Forest (2,5)

TIL sn
11101010
11111111
10101110
11111011
11111111
11110101
01111111
11011010
NAME Forest (3,5)

TIL so
10100010
11110100
10000000
10101010
10101000
10010000
10000110
10100100
NAME Forest (4,5)

TIL sp
00010001
11010001
01000001
10111001
01000001
00000010
10010000
01000000
NAME Forest (5,5)

TIL sq
00010001
00000101
00100001
00010001
01000000
00000000
00000001
00000100
NAME Forest (6,5)

TIL sr
01010000
01101010
10111010
11101010
11111001
00000000
00000010
00000000
NAME Forest (7,5)

TIL ss
00101000
10101010
10101000
10101010
01011000
00000000
00000000
10100000
NAME Forest (8,5)

TIL st
10001010
10001101
11000111
10001110
11001111
00000000
00001000
00000000
NAME Forest (9,5)

TIL su
10100000
10100000
11100000
10100000
11000000
00000000
00000000
00101000
NAME Forest (10,5)

TIL sv
00000101
01000111
00000110
01000111
00000011
00000000
00000000
00000000
NAME Forest (11,5)

TIL sw
01011010
10101000
11110110
01011010
01110001
00000001
00001010
00000001
NAME Forest (12,5)

TIL sx
10110010
10101011
10010111
01110101
10011111
01011011
10001011
00000110
NAME Forest (13,5)

TIL sy
11110000
10110010
11111111
01010110
11111010
01101100
11110001
10100111
NAME Forest (14,5)

TIL sz
00000010
00000111
00000011
10000110
00100110
00110101
11001100
01000010
NAME Forest (15,5)

TIL t0
00101011
00101011
00010110
00011100
00111010
11000100
00001010
00001000
NAME Forest (0,6)

TIL t1
01000010
01000010
00000010
00000101
00000010
00000010
00010010
00000010
NAME Forest (1,6)

TIL t2
11000000
10000000
00000000
10000000
00000000
10000000
00000000
10000000
NAME Forest (2,6)

TIL t3
01111111
01101011
11111110
01011011
01111111
01101101
11110111
00111101
NAME Forest (3,6)

TIL t4
00110001
00000000
00100000
00010000
00000000
00000000
10000000
00000000
NAME Forest (4,6)

TIL t5
10101101
11111111
10010001
01010001
01000001
01010001
01000001
00100001
NAME Forest (5,6)

TIL t6
10101010
11111111
00010011
00010011
00000010
00100010
00010010
00010011
NAME Forest (6,6)

TIL t7
10101010
11111111
11110001
10100000
10100001
11100000
11000000
11100000
NAME Forest (7,6)

TIL t8
01010110
11111111
10101011
00000000
01100100
10000000
10100000
10000000
NAME Forest (8,6)

TIL t9
11101010
11111111
01011111
00000011
01001101
00000111
01000011
00000110
NAME Forest (9,6)

TIL ta
11001010
11111111
11110000
01010000
11100000
01110000
11010000
11110000
NAME Forest (10,6)

TIL tb
10101101
11111111
01000101
00000101
01000100
00000101
01000101
00000101
NAME Forest (11,6)

TIL tc
01010110
11111101
11111010
10110010
11011010
01111000
11011000
01111010
NAME Forest (12,6)

TIL td
01010111
01001011
10001001
10010011
01010011
01000001
01000011
10000010
NAME Forest (13,6)

TIL te
11100001
01100010
11100000
10100000
11100001
01100000
11100000
10100000
NAME Forest (14,6)

TIL tf
01000001
00000100
00000111
00000101
01010010
00000111
01010101
00000010
NAME Forest (15,6)

TIL tg
00001100
00001010
00000100
00010100
00001010
00010100
00101010
01010101
NAME Forest (0,7)

TIL th
00000010
00000010
00100010
01000010
10000101
00000101
01000101
10100101
NAME Forest (1,7)

TIL ti
10000010
10000010
00000001
10001000
01000000
00010000
00010000
00100001
NAME Forest (2,7)

TIL tj
01101111
11111011
10111110
11101111
11110101
10111111
11101101
10111111
NAME Forest (3,7)

TIL tk
10000000
10000000
10000000
10000000
10000000
00100000
10000001
00000001
NAME Forest (4,7)

TIL tl
01000001
10100001
01000001
10100001
10000001
10110001
01000001
01010101
NAME Forest (5,7)

TIL tm
00000110
00100110
00000111
00000101
00100111
00000101
00010111
10000101
NAME Forest (6,7)

TIL tn
10100000
11100001
11000000
01100010
11100010
01000010
11100001
01100000
NAME Forest (7,7)

TIL to
01000000
01000000
10000000
10000100
10000000
10101010
01010100
10100001
NAME Forest (8,7)

TIL tp
00000011
00000111
00000101
00000111
00000110
00000111
00000010
00000111
NAME Forest (9,7)

TIL tq
10110010
11100000
01110000
11011000
11110000
10110100
11111000
11010100
NAME Forest (10,7)

TIL tr
01000100
00000100
00000100
00000110
00100100
01000100
00000110
01000111
NAME Forest (11,7)

TIL ts
11010100
01111100
11101000
11111100
10110100
11111000
01011100
01110100
NAME Forest (12,7)

TIL tt
00000011
01000111
00000011
00000110
00000011
00000110
00000011
10000111
NAME Forest (13,7)

TIL tu
11100000
01100000
11100000
10110110
11100000
11010010
11110100
01110000
NAME Forest (14,7)

TIL tv
01001011
10101010
10101001
10001100
10101010
00010010
01000111
00001101
NAME Forest (15,7)

TIL tw
01010100
10111010
01101010
11110000
10111101
01101100
01111111
01011010
NAME Forest (0,8)

TIL tx
00001010
10001010
00010101
00101010
10110101
10110101
10101111
10111011
NAME Forest (1,8)

TIL ty
10010011
10101001
01010101
10101011
00101011
11111111
01011011
11111110
NAME Forest (2,8)

TIL tz
11101011
01111110
11011011
11111111
01101101
11110111
01011110
11111011
NAME Forest (3,8)

TIL u0
10000001
00000001
11110101
01010010
11101010
10111010
11111010
10100101
NAME Forest (4,8)

TIL u1
01000001
01001011
01000111
10110101
10110111
10011101
10110111
01111111
NAME Forest (5,8)

TIL u2
00010111
00000101
01010111
00000101
00010111
00010101
01000110
00010101
NAME Forest (6,8)

TIL u3
11000011
01110100
11100101
01110101
11010010
01101011
11111111
11011011
NAME Forest (7,8)

TIL u4
01010010
10101010
01010101
01010101
10101010
01101011
01111101
10110111
NAME Forest (8,8)

TIL u5
10101011
00000011
00000011
01001111
10111010
01101111
11111011
01011111
NAME Forest (9,8)

TIL u6
01111010
11011000
01110000
11111010
10101110
11111111
01101010
11111111
NAME Forest (10,8)

TIL u7
00000110
01000111
01000110
00000111
01000110
00000111
01000110
00000111
NAME Forest (11,8)

TIL u8
11011100
11111110
10101011
11111110
10110111
11111101
10101110
11111011
NAME Forest (12,8)

TIL u9
00001101
00000111
00011101
00010111
01100110
01110111
11011101
11111111
NAME Forest (13,8)

TIL ua
11010101
01110010
11101100
10111101
11110110
11011110
11111011
01011110
NAME Forest (14,8)

TIL ub
00010101
01011010
10001101
00100101
11001011
11100110
10000101
11111010
NAME Forest (15,8)

TIL uc
01111111
01101011
11111101
01001110
00100011
10010101
01001111
10111011
NAME Forest (0,9)

TIL ud
11101110
01011111
11110101
11011110
01001011
11100111
00001101
00010011
NAME Forest (1,9)

TIL ue
11010111
11111101
01010100
11101001
10111101
01111011
11011110
00101011
NAME Forest (2,9)

TIL uf
01101111
00111101
11101101
00010101
00111100
11000011
11011000
11010000
NAME Forest (3,9)

TIL ug
11111010
01011111
11110111
10111101
11010011
10110001
11100100
11000110
NAME Forest (4,9)

TIL uh
10101011
10111111
11101101
01110111
11011111
01110111
11011011
01110111
NAME Forest (5,9)

TIL ui
00010111
00010101
01000110
00010101
00010111
00000101
00100111
00000101
NAME Forest (6,9)

TIL uj
01111101
11101111
11110101
10111111
11101101
01110111
11101111
01111101
NAME Forest (7,9)

TIL uk
11011111
01111010
11101111
10111101
11101111
01111010
11011111
10110101
NAME Forest (8,9)

TIL ul
11110101
11011111
11111011
10110111
11101110
10111111
11101011
01111111
NAME Forest (9,9)

TIL um
01011011
11111110
01101011
11111110
10101111
11110110
01111011
10101110
NAME Forest (10,9)

TIL un
00000110
01000111
00000111
01000110
00000111
01000110
00010111
01000110
NAME Forest (11,9)

TIL uo
11011111
01110101
11011111
11111110
01101111
11110101
11011110
10110111
NAME Forest (12,9)

TIL up
01101011
11111110
10101111
11110110
10100111
11110011
10000110
10001001
NAME Forest (13,9)

TIL uq
11110111
11011101
11110111
10111101
11101111
01110110
11111111
10001011
NAME Forest (14,9)

TIL ur
11011001
01110101
11010101
11101011
01001011
11101101
11010111
01010011
NAME Forest (15,9)

TIL us
10101110
01111101
01101111
10110101
10011111
10111101
10001110
11110111
NAME Forest (0,10)

TIL ut
11100101
11111101
10101101
11111011
01011111
11101010
10111111
11110110
NAME Forest (1,10)

TIL uu
00111110
01011011
01101111
00111101
01110111
11101110
11011011
11111111
NAME Forest (2,10)

TIL uv
11111010
01101110
11111010
01011110
11101011
11101110
10111111
01101101
NAME Forest (3,10)

TIL uw
00111111
00010100
01011111
11101101
10110111
11111111
01011011
11111101
NAME Forest (4,10)

TIL ux
11011101
11101111
11110001
01011010
11111001
01101101
11111000
01010111
NAME Forest (5,10)

TIL uy
00001111
01010001
10011001
01001011
00100010
01111001
10000111
11001001
NAME Forest (6,10)

TIL uz
10110111
11101110
01111101
11010111
10111110
11111011
01101110
11001111
NAME Forest (7,10)

TIL v0
11111111
10110110
11111111
10101010
11111111
10110101
11111111
10101011
NAME Forest (8,10)

TIL v1
11011011
11111101
10101111
11111010
10101111
11111011
01101110
10111011
NAME Forest (9,10)

TIL v2
01111111
11101011
10111110
11101111
11111011
01101110
11111011
10101111
NAME Forest (10,10)

TIL v3
00111110
01010100
00010000
01000001
00101111
11011011
11101110
01111101
NAME Forest (11,10)

TIL v4
01111011
01011111
11101101
00110001
01010101
11000010
11010011
11110101
NAME Forest (12,10)

TIL v5
01111001
10101110
11111010
01101110
11011011
11111101
01110111
11011101
NAME Forest (13,10)

TIL v6
01001110
10011011
10001100
10001111
10100101
01110100
11100101
11011011
NAME Forest (14,10)

TIL v7
00110110
10001011
01110110
01001111
01101011
11100111
10101011
11101101
NAME Forest (15,10)

TIL v8
11011101
01111111
11010101
11111111
10110101
11101111
01111010
11011111
NAME Forest (0,11)

TIL v9
01011111
11101101
10111011
01101111
11111011
01101110
11011111
11110101
NAME Forest (1,11)

TIL va
10101011
11111110
10101011
01111110
11010111
11111010
10101111
11111101
NAME Forest (2,11)

TIL vb
11111101
10101111
11111010
10101111
11111111
10101011
11111111
01010101
NAME Forest (3,11)

TIL vc
10101011
11111110
10101101
11111011
01011111
11101101
01110111
11011101
NAME Forest (4,11)

TIL vd
11111110
11010111
11111010
10011101
11110111
01011110
11111011
01011111
NAME Forest (5,11)

TIL ve
10111001
11101100
11011110
10111011
11101110
10111011
11101111
10111011
NAME Forest (6,11)

TIL vf
00001010
01011111
10010101
11011011
10101110
11111011
01101110
11111011
NAME Forest (7,11)

TIL vg
11111110
11011011
01110111
11101110
10111011
11111111
10101010
11111111
NAME Forest (8,11)

TIL vh
11111111
11010101
01111111
11010101
11111111
01101101
11110111
11011101
NAME Forest (9,11)

TIL vi
11111101
01011111
11110101
01101111
11011101
01111011
11011110
01110111
NAME Forest (10,11)

TIL vj
11010111
01111101
11011111
01110101
11011111
11110110
10111111
11101010
NAME Forest (11,11)

TIL vk
10111011
01101111
11111010
01011111
11101011
11111101
10110111
11011111
NAME Forest (12,11)

TIL vl
01111011
11101101
10110111
11101111
01110111
11011101
01111111
11010101
NAME Forest (13,11)

TIL vm
01111111
11010110
01111111
11010101
01111111
11101111
10111010
11101111
NAME Forest (14,11)

TIL vn
01010111
11101111
10111011
11011110
01101101
11011011
11111111
01101011
NAME Forest (15,11)

TIL vo
01110110
11111111
01011010
11111111
01101011
10111111
01110111
10111010
NAME Forest (0,12)

TIL vp
11011111
11111011
10101111
11111111
01110101
01011111
11111011
11011110
NAME Forest (1,12)

TIL vq
01010111
11111101
01101011
01111110
11010101
01111011
11011111
10110110
NAME Forest (2,12)

TIL vr
11111111
11011011
11111111
11011010
10110111
11111110
01101111
11110101
NAME Forest (3,12)

TIL vs
10111011
01101111
11110101
11011111
11110110
10111111
11101010
01111111
NAME Forest (4,12)

TIL vt
11110101
01111110
10101011
11111110
10101101
11111011
10101111
11111011
NAME Forest (5,12)

TIL vu
10111110
11101011
10111111
11110111
11011101
11110111
01011101
11110111
NAME Forest (6,12)

TIL vv
10101111
11111011
01101101
10111011
11101111
01111111
11011011
11101101
NAME Forest (7,12)

TIL vw
01101110
11110101
01011111
11111011
01011110
11110111
01011101
11101111
NAME Forest (8,12)

TIL vx
10111011
11111111
10101011
11111110
10101011
11111110
10101111
01111011
NAME Forest (9,12)

TIL vy
11101101
01111011
11011110
11110111
10111010
11101111
10111011
01111111
NAME Forest (10,12)

TIL vz
01111111
11010110
10111011
11101111
11111110
11010111
01111101
11101111
NAME Forest (11,12)

TIL w0
11110101
10111111
11101101
10111101
11101111
10111010
11101111
11111010
NAME Forest (12,12)

TIL w1
01111110
10101011
11111111
10101011
11111111
10101101
11111110
10110111
NAME Forest (13,12)

TIL w2
11011011
10111110
11101011
01111110
11011011
11111101
10110111
11101111
NAME Forest (14,12)

TIL w3
11111111
10110111
11111101
10110111
11111101
10111110
11101111
01110101
NAME Forest (15,12)

TIL w4
01101111
11110101
01011011
11111111
01101010
11011111
11111101
10110111
NAME Forest (0,13)

TIL w5
11110111
01110101
10111111
11101011
10110101
11011111
01111101
11101110
NAME Forest (1,13)

TIL w6
11111111
01101011
10111110
11101111
00111011
11101110
10111011
11101101
NAME Forest (2,13)

TIL w7
10111111
11010110
11111101
01011111
11110101
10111111
11101010
01111111
NAME Forest (3,13)

TIL w8
11011010
10111111
11101011
11111111
01010101
11111111
11011011
01101101
NAME Forest (4,13)

TIL w9
11011110
01110111
11101101
01111111
11010101
01111111
11011011
01101101
NAME Forest (5,13)

TIL wa
10111110
11110010
01011111
11111111
11101011
01111111
10101010
01111111
NAME Forest (6,13)

TIL wb
10111010
11101111
11011010
01111111
11101110
10111011
11101110
10111011
NAME Forest (7,13)

TIL wc
11011011
01111110
11101011
10111101
11110111
11011101
11111111
10110101
NAME Forest (8,13)

TIL wd
11101101
11011111
10111010
11101111
10111101
11110111
01011111
11110101
NAME Forest (9,13)

TIL we
11010101
11111111
11010101
10111111
11111011
01010111
11111101
10101111
NAME Forest (10,13)

TIL wf
01111010
11011111
01110101
11011111
01110111
11011011
01110110
11011111
NAME Forest (11,13)

TIL wg
10111111
11010101
11111111
01101101
01111011
11011111
11110111
11101101
NAME Forest (12,13)

TIL wh
11110110
11011011
01101110
11111011
10101010
10111111
01101101
11110111
NAME Forest (13,13)

TIL wi
11111011
01010110
11111111
11011101
11110111
10111101
11110111
10111111
NAME Forest (14,13)

TIL wj
10111111
11110110
11011010
01101111
11111111
11110110
01011111
11111111
NAME Forest (15,13)

TIL wk
11111011
11101111
01111110
11101011
10111111
11111011
11111110
11111111
NAME Forest (0,14)

TIL wl
01011011
11111111
11101011
01111101
10110111
11011110
11111011
11011110
NAME Forest (1,14)

TIL wm
11110111
10111110
11110111
01011101
11101110
11111011
10111111
11101011
NAME Forest (2,14)

TIL wn
10101111
11110110
10111011
10111101
11010111
11111010
01011101
11110111
NAME Forest (3,14)

TIL wo
01111011
11011110
11101011
01111110
11010101
11111111
01011010
11110111
NAME Forest (4,14)

TIL wp
11111110
10101011
11111111
11010101
10111110
11101111
11011011
01111101
NAME Forest (5,14)

TIL wq
11101110
11111011
01011010
11111111
11101011
01111110
10101011
11111110
NAME Forest (6,14)

TIL wr
11111110
10101111
11110101
01011111
11110101
10101111
11111010
10101111
NAME Forest (7,14)

TIL ws
11011110
01110110
11111011
01011101
11101011
01111111
11011010
11111111
NAME Forest (8,14)

TIL wt
11011110
10111011
11101110
01110111
10111011
11011110
11110101
10111111
NAME Forest (9,14)

TIL wu
11111010
10101111
11111010
10101111
11110111
10111101
11101011
01011110
NAME Forest (10,14)

TIL wv
11111010
10101111
11111011
11101111
01011011
11111110
10101011
11111110
NAME Forest (11,14)

TIL ww
10111111
10111110
01101011
11111101
10101111
11111111
10101010
11111101
NAME Forest (12,14)

TIL wx
10111101
01101011
11101111
10111111
01111101
11010111
11111111
01011011
NAME Forest (13,14)

TIL wy
11111011
01011111
11111111
10111111
11110110
10111111
11111111
11111111
NAME Forest (14,14)

TIL wz
11111111
11111111
11111111
11111101
11111111
11111111
11111111
11111111
NAME Forest (1,15)

TIL x0
11111101
11101011
11011110
11111111
11111101
11111111
11111111
11111111
NAME Forest (2,15)

TIL x1
10101101
11110111
10111101
10101011
11011110
01111011
11011110
11101011
NAME Forest (3,15)

TIL x2
10111110
01101011
11111111
10110101
11101011
10111110
11101011
10111101
NAME Forest (4,15)

TIL x3
11010110
01111011
11011110
11101011
01011101
11111011
10101101
11111011
NAME Forest (5,15)

TIL x4
10101011
11111101
10101011
11110110
00111111
11101101
11011011
01111111
NAME Forest (6,15)

TIL x5
11111101
10101111
11111011
11011111
11101010
10111111
11010101
01111111
NAME Forest (7,15)

TIL x6
01010110
11111111
10110110
11011011
11101111
01111101
11010110
01111111
NAME Forest (8,15)

TIL x7
11010101
11111111
10110111
11101101
01111111
10101101
11111111
11010110
NAME Forest (9,15)

TIL x8
11110110
01111011
11011111
01110101
11111111
01010101
11111111
10101010
NAME Forest (10,15)

TIL x9
10110111
11111101
10100111
11111011
01011101
11101111
10110101
11011111
NAME Forest (11,15)

TIL xa
01011011
11111111
10101111
11111011
01101101
11101110
01011010
10111011
NAME Forest (12,15)

TIL xb
11111111
10111111
01111111
11111111
10111111
11111111
11111111
11111111
NAME Forest (13,15)

TIL xc
11111111
11111111
11101111
11111011
11101111
11111111
11111111
11111111
NAME Forest (15,15)

TIL xd
11101111
11111111
01111111
10111111
10101111
11000001
00000000
00000000
NAME Cat (0,0)

TIL xe
11110111
11101110
11100011
01011011
11100111
11010101
01010110
00010101
NAME Cat (1,0)

TIL xf
11111111
10101111
11111000
01100101
11010101
11010111
10101010
11110111
NAME Cat (2,0)

TIL xg
11111111
11010111
11111110
11111111
10111111
11110111
11011101
11110011
NAME Cat (3,0)

TIL xh
11111111
01101110
11111011
11011111
11110111
11111111
11111111
11111111
NAME Cat (4,0)

TIL xi
11111111
10111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Cat (5,0)

TIL xj
11111111
11111111
11111110
11100000
11100010
11001000
11000101
11011110
NAME Cat (6,0)

TIL xk
11111111
11111111
01111111
10111100
01101000
11011110
10011100
01011110
NAME Cat (7,0)

TIL xl
11111111
11111111
11111111
01111111
00111101
10011111
01011111
10011111
NAME Cat (8,0)

TIL xm
11010111
11011111
11101111
11111111
11111111
11111111
11101111
11111111
NAME Cat (9,0)

TIL xn
11100001
11000100
11101001
11010101
11011010
01110101
11111011
10110110
NAME Cat (10,0)

TIL xo
01010000
10101001
01011111
00100110
11010101
01101101
10010101
10101010
NAME Cat (11,0)

TIL xp
00011101
00001010
01001111
01011111
01011111
01111111
01111110
11111111
NAME Cat (12,0)

TIL xq
10111011
11011101
11101110
10110101
01101111
10111011
11101101
10111110
NAME Cat (13,0)

TIL xr
01010111
01011011
10101111
01111111
11111111
01101101
10100111
11001111
NAME Cat (14,0)

TIL xs
00000111
11001111
11101111
11111111
01111111
11111011
11111111
11111110
NAME Cat (15,0)

TIL xt
11000000
11101010
11111010
10100101
11101010
10111010
11010111
01111101
NAME Cat (0,1)

TIL xu
00001010
00011011
00001111
00001011
00000111
10010100
01010110
10101010
NAME Cat (1,1)

TIL xv
00111111
01011111
01011110
10101111
11011111
11101110
01111100
10011101
NAME Cat (2,1)

TIL xw
01111000
11011100
11111110
10111111
10101111
00010001
10101110
00110010
NAME Cat (3,1)

TIL xx
00111110
01011000
00111001
10010000
11010101
00000111
00000001
00000000
NAME Cat (4,1)

TIL xy
00111111
00101111
01111011
11011111
11110111
11111101
01011111
01111011
NAME Cat (5,1)

TIL xz
11111110
10110110
11111110
10110110
11111110
11011111
11110111
11011111
NAME Cat (6,1)

TIL y0
10011111
00111111
10011111
01111111
01111111
11111111
11111010
10111111
NAME Cat (7,1)

TIL y1
00111111
11111011
11111111
11111111
11101111
11111101
11111110
11111011
NAME Cat (8,1)

TIL y2
01111110
11111111
11111110
11101111
01011111
11111111
10111111
11010111
NAME Cat (9,1)

TIL y3
11011111
01111010
11101111
10111110
01110101
11011111
01110101
11101110
NAME Cat (10,1)

TIL y4
10101111
11010111
01111111
11101011
10111111
11111011
11111101
11111111
NAME Cat (11,1)

TIL y5
01111110
11111111
11101111
01110101
11011110
11101011
01111101
11111111
NAME Cat (12,1)

TIL y6
11111101
11111111
11100000
11101010
11111111
01111111
10111100
11111010
NAME Cat (13,1)

TIL y7
10100111
11001111
11000111
00111111
01101111
11110110
00010011
10100101
NAME Cat (14,1)

TIL y8
11111000
11110010
11100000
11001010
10100001
11111111
11111111
11111111
NAME Cat (15,1)

TIL y9
11101011
11111111
11111111
11001111
11001110
11000111
11010011
11001011
NAME Cat (0,2)

TIL ya
10010100
10101001
11010010
11111000
11110010
11110000
11110101
11110011
NAME Cat (1,2)

TIL yb
00101100
00001011
10101111
11010111
11000111
11110101
11111111
11111111
NAME Cat (2,2)

TIL yc
11100100
11010010
10001010
10100101
10010111
10101111
10011011
11110111
NAME Cat (3,2)

TIL yd
00000000
00000000
01000010
11000011
11000011
11000110
11000110
01101111
NAME Cat (4,2)

TIL ye
00101001
00010111
00001010
10010100
01010110
10101110
11111111
11111110
NAME Cat (5,2)

TIL yf
11111110
00111111
00111011
10111100
00110101
11110101
01110101
11111110
NAME Cat (6,2)

TIL yg
11101000
11110101
01101010
10111101
01010111
00101011
11100101
11010101
NAME Cat (7,2)

TIL yh
11111101
00111111
10101111
01001011
10111110
11101111
01011101
11111111
NAME Cat (8,2)

TIL yi
01111111
11010101
11101111
11011010
11111111
10111111
11111111
10111111
NAME Cat (9,2)

TIL yj
11111011
11110110
11111111
11111011
11111111
11111111
11101110
10111111
NAME Cat (10,2)

TIL yk
11110101
11101111
11110101
10101111
11111011
11010111
11111111
11011011
NAME Cat (11,2)

TIL yl
01111110
11111011
01101111
11111111
11111111
11111111
10111101
11111110
NAME Cat (12,2)

TIL ym
11111000
11111010
11111011
11101111
11111111
11111111
11111111
00110110
NAME Cat (13,2)

TIL yn
00100001
11111010
11111001
11111100
11101111
11111111
11110101
11011011
NAME Cat (14,2)

TIL yo
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11110111
NAME Cat (15,2)

TIL yp
11000011
11101011
01111110
01100111
10010101
00000100
00101101
00001100
NAME Cat (0,3)

TIL yq
11111011
00001111
10100011
00001011
10000000
01101000
00111111
10111111
NAME Cat (1,3)

TIL yr
11110111
11011010
01101111
10110110
11111110
01111011
11111110
11110101
NAME Cat (2,3)

TIL ys
11011111
11111101
10110111
11010110
11100011
01010010
11100101
10100001
NAME Cat (3,3)

TIL yt
10111111
01101101
10110110
11111101
11111011
10111111
11010101
01111011
NAME Cat (4,3)

TIL yu
11110001
11000101
10100000
10010110
01001111
00111111
11111111
11011011
NAME Cat (5,3)

TIL yv
00111111
00011110
01011111
10011111
00111100
00111101
10111100
11111100
NAME Cat (6,3)

TIL yw
11010101
11100111
11101010
11110111
11111011
11111111
01111111
10111111
NAME Cat (7,3)

TIL yx
01011111
11111101
11110101
11110101
11101011
11101011
11101111
11110101
NAME Cat (8,3)

TIL yy
10101110
01010111
11101011
00011011
00011111
00001111
10001111
11001111
NAME Cat (9,3)

TIL yz
11111111
11111010
11111101
11101011
11111111
01010110
11111111
11011111
NAME Cat (10,3)

TIL z0
11111111
11011110
10110111
11111010
10101111
11110101
10101111
01111111
NAME Cat (11,3)

TIL z1
11111101
11111000
01011010
11111111
10101111
01111111
11111100
11111010
NAME Cat (12,3)

TIL z2
10011001
10101010
11110101
11101010
11101011
01101111
11111111
11111111
NAME Cat (13,3)

TIL z3
00100100
11110101
01011100
10101111
10101111
10101111
10100111
10101111
NAME Cat (14,3)

TIL z4
10111111
11111111
01111111
01111111
11111101
11111011
11111110
11011011
NAME Cat (15,3)

TIL z5
01011110
00111110
01111111
01111111
01111111
01111111
01000000
11001001
NAME Cat (0,4)

TIL z6
00011111
10101111
01001111
10101111
11101111
11110111
10101111
01111110
NAME Cat (1,4)

TIL z7
11111111
11110101
11011111
11110111
11011011
01110110
11111111
10111110
NAME Cat (2,4)

TIL z8
01101011
11100001
11111001
11111011
11111011
11111110
11111111
11111101
NAME Cat (3,4)

TIL z9
10101110
11110111
10101101
01111111
11010101
10111110
01111011
11111110
NAME Cat (4,4)

TIL za
10110111
11101111
01111111
11111111
10111111
11111110
01011100
11101100
NAME Cat (5,4)

TIL zb
11111100
11111101
11111110
00000111
00000110
00001000
00011010
01110001
NAME Cat (6,4)

TIL zc
00111111
01111111
00110000
11101010
10110000
01011000
11000110
01101011
NAME Cat (7,4)

TIL zd
11111111
11111101
11110111
01111111
10011111
00001111
01000110
11111000
NAME Cat (8,4)

TIL ze
01101111
11111110
11011011
01111111
11111111
11111111
01111111
11111111
NAME Cat (9,4)

TIL zf
11111111
11111111
11111111
11111011
11101111
11111111
11111111
11111111
NAME Cat (10,4)

TIL zg
11010111
01111111
11010111
11111111
11011111
11111101
11101111
01111111
NAME Cat (11,4)

TIL zh
11110100
11110011
01111011
11110111
11111111
11111111
10111111
11110111
NAME Cat (12,4)

TIL zi
11110101
11011111
11101011
01111111
10101111
11111111
11111111
01111111
NAME Cat (13,4)

TIL zj
11011111
11111111
01111111
11011111
01111101
10101111
11111111
01101110
NAME Cat (14,4)

TIL zk
01111111
11011101
10110111
11101111
11111011
10111111
11010111
11101101
NAME Cat (15,4)

TIL zl
01100000
00011010
10101111
00010111
10100111
10000011
01010111
11100001
NAME Cat (0,5)

TIL zm
00111011
01011101
10110111
01111011
11010111
11111101
11010111
11111011
NAME Cat (1,5)

TIL zn
11110111
01111111
10110111
11111011
11111101
11111011
11101110
11110111
NAME Cat (2,5)

TIL zo
11111111
11011011
01110111
11011101
11101111
11110101
11111111
01111111
NAME Cat (3,5)

TIL zp
11111010
11110101
11101001
01111111
11111111
01111111
11110110
11111110
NAME Cat (4,5)

TIL zq
10111011
00011111
01000101
10110111
01001010
01010110
10101101
10111101
NAME Cat (5,5)

TIL zr
11101000
11110101
11110011
11110111
01111111
10111001
01111010
00110101
NAME Cat (6,5)

TIL zs
11000101
11010011
11101001
11110000
11111101
11111110
01111111
01110111
NAME Cat (7,5)

TIL zt
11110000
11110001
11111001
11111110
11010110
10101010
01011110
01110101
NAME Cat (8,5)

TIL zu
11111111
11111111
11111111
00111111
00001111
00001110
00000011
10101111
NAME Cat (9,5)

TIL zv
11111110
11011111
11111110
10111111
11101111
11111111
10110101
11111110
NAME Cat (10,5)

TIL zw
11111111
10111011
11011110
01101101
11111111
01101011
10111110
11000001
NAME Cat (11,5)

TIL zx
11111111
01101111
11011111
10111111
01101111
11111000
11100000
11000111
NAME Cat (12,5)

TIL zy
11111101
11111111
11111111
11110111
11111011
01101101
11110111
11011111
NAME Cat (13,5)

TIL zz
11111111
11111111
11111111
11010111
01111110
11010111
10111011
11101111
NAME Cat (14,5)

TIL 10a
11111111
01110111
11011111
01110101
10010111
01010101
10101111
10101000
NAME Cat (9,6)

TIL 10b
10110111
11111111
01111101
11111111
11111101
11111111
11010111
01111110
NAME Cat (10,6)

TIL 10c
00100000
10000110
00011100
01011100
01110100
11011100
01111100
11111101
NAME Cat (11,6)

TIL 10d
10111111
00001001
00000010
00001001
00000100
00110010
11111000
11111010
NAME Cat (12,6)

TIL 10e
10110111
11011101
11111110
10110111
11111010
10000000
10000001
00000010
NAME Cat (14,6)

TIL 10f
01111111
11011111
11111110
01111111
11111010
00111111
00011010
10001101
NAME Cat (15,6)

TIL 10g
10000001
11011101
11000001
00101010
01001000
11111100
10111000
10100000
NAME Cat (0,7)

TIL 10h
00100111
01011101
10101111
11110111
01011111
00100001
00010101
01010101
NAME Cat (1,7)

TIL 10i
01111110
11110101
11011110
01110101
10111111
11011110
01101010
01011010
NAME Cat (2,7)

TIL 10j
11111111
10111011
11011101
11101011
11111110
11111111
11111110
00011000
NAME Cat (3,7)

TIL 10k
01111111
11111111
11111101
01111010
11111111
11100000
00100000
00001101
NAME Cat (4,7)

TIL 10l
11000100
11000100
11000100
10000111
11001111
11111111
00111111
10001101
NAME Cat (5,7)

TIL 10m
01011101
11111111
11111111
10000001
11000010
11111100
11100010
11000010
NAME Cat (6,7)

TIL 10n
11101010
01110100
10101101
11111111
10101101
01110000
00100000
01111111
NAME Cat (7,7)

TIL 10o
11101011
11010101
10101111
11100111
01011100
11111000
11011100
01111101
NAME Cat (8,7)

TIL 10p
01011101
01111110
11111011
01011111
00001010
00000111
00000011
01000011
NAME Cat (9,7)

TIL 10q
00011111
01010111
11111101
10000011
10011001
00101010
00001000
01011110
NAME Cat (10,7)

TIL 10r
11111110
11111111
11111111
11111111
11111111
11111101
11111111
11111111
NAME Cat (11,7)

TIL 10s
11111100
11111110
11111111
11011111
01111100
11111010
11110101
11111111
NAME Cat (12,7)

TIL 10t
11111111
11111011
11101000
11101011
10111101
01011111
11111111
10010101
NAME Cat (13,7)

TIL 10u
00010001
01110000
11100001
01100001
11100011
11110011
01011111
01111111
NAME Cat (14,7)

TIL 10v
11000111
11001111
11111111
11101111
01111111
11011111
01111101
11111111
NAME Cat (15,7)

TIL 10w
01010000
10101000
01111100
11110011
11101001
11101010
11010101
11010101
NAME Cat (0,8)

TIL 10x
01111111
10101100
01010110
01010101
10101010
10100111
11010111
11110110
NAME Cat (1,8)

TIL 10y
01011010
10001101
10101011
01100111
11101001
11101011
11111010
00101011
NAME Cat (2,8)

TIL 10z
11001000
00111000
11111101
11111111
11100100
11010101
10101101
10100111
NAME Cat (3,8)

TIL 11a
00010111
11011111
11110111
11111110
11111111
11110001
11100000
11101110
NAME Cat (14,8)

TIL 11b
11010011
10000110
00000111
00000101
00001010
00101010
00110101
10001111
NAME Cat (15,8)

TIL 11c
11101011
11100111
11101101
10111111
11110111
10111100
11110110
10110101
NAME Cat (0,9)

TIL 11d
11111110
11101101
11111111
11101101
11111111
11111111
01101111
11111100
NAME Cat (1,9)

TIL 11e
10101111
01011001
11100101
11010100
10101010
11010000
01110000
00010010
NAME Cat (2,9)

TIL 11f
10101111
11010111
11010111
11110000
01011100
10001110
11100010
01110010
NAME Cat (3,9)

TIL 11g
11101111
11111111
11111111
01111011
00011111
00011111
00011011
01000111
NAME Cat (4,9)

TIL 11h
11100000
11100011
11111110
11100010
11011001
11001011
11111100
10011011
NAME Cat (5,9)

TIL 11i
00010110
00101110
01011111
11111111
10011111
10100111
00101111
11010011
NAME Cat (6,9)

TIL 11j
11001111
11101111
01011111
11111111
11111111
11111111
11111111
11111111
NAME Cat (7,9)

TIL 11k
11111111
11001111
10011111
11111111
11111110
11111101
11111101
11111100
NAME Cat (8,9)

TIL 11l
11010001
00100000
01000111
11100011
00100011
10100011
01100111
11100100
NAME Cat (9,9)

TIL 11m
11101001
11111010
01110001
11110100
11110011
11100001
01100000
11100000
NAME Cat (10,9)

TIL 11n
11111110
00001010
01010101
00101011
10011100
11001111
11111100
00001111
NAME Cat (11,9)

TIL 11o
10011110
11111101
11110010
11111101
00000010
10101001
10010100
01010101
NAME Cat (12,9)

TIL 11p
11111011
11010101
00110100
10110101
11011111
01010111
10101001
01010101
NAME Cat (13,9)

TIL 11q
11110000
11010000
01100000
11100011
11001111
11111111
11110111
10111111
NAME Cat (14,9)

TIL 11r
10000111
01000111
11011111
11111000
11011011
11111111
01000001
01011101
NAME Cat (15,9)

TIL 11s
11101010
11010101
10101011
10101111
10111011
11101110
10101010
00101011
NAME Cat (0,10)

TIL 11t
10111110
11101111
11111010
01101110
11111100
11011110
11111111
10101111
NAME Cat (1,10)

TIL 11u
00000111
00000000
00001000
00001000
00110110
11111101
10101111
11111001
NAME Cat (2,10)

TIL 11v
11111000
01000000
01000000
00000000
00000101
01110001
10111101
01101011
NAME Cat (3,10)

TIL 11w
10101110
00110101
00001000
00000000
00000000
01101000
11110000
11111000
NAME Cat (4,10)

TIL 11x
01111010
10111010
01010101
10100000
10000000
01000000
11111010
11111010
NAME Cat (5,10)

TIL 11y
10110111
11100011
01000001
01100001
00110000
00100001
10010000
01011000
NAME Cat (6,10)

TIL 11z
11111111
11111111
11111111
11111111
01111111
00001111
00011111
01111111
NAME Cat (7,10)

TIL 12a
01111111
11011010
11111111
01101101
11111110
11011010
11111110
10110111
NAME Cat (2,11)

TIL 12b
01010101
10010101
01010010
01010101
10101010
10110100
11011011
01111100
NAME Cat (3,11)

TIL 12c
10001000
00000001
00001000
00101000
10111000
11110100
01111010
11011111
NAME Cat (4,11)

TIL 12d
11110101
10000001
01000010
00000100
00111100
11101010
11011100
01111101
NAME Cat (5,11)

TIL 12e
00010001
01100100
00101000
10100110
01010011
10100101
01001001
01010011
NAME Cat (6,11)

TIL 12f
11111111
01111111
01111111
00011110
11111101
11110010
11111001
11110111
NAME Cat (7,11)

TIL 12g
11111111
11111111
11111101
11111000
11111111
11111111
11111111
11111001
NAME Cat (8,11)

TIL 12h
11111101
10100101
00011011
10011000
01111010
11111000
11111101
11111011
NAME Cat (9,11)

TIL 12i
01111010
10101111
11111111
10011110
10001111
10001101
10001110
11001101
NAME Cat (10,11)

TIL 12j
11111110
01111011
11011101
11101111
01011111
11111000
10100101
11110101
NAME Cat (11,11)

TIL 12k
10111111
01110111
11111101
11111111
11111111
01111111
10111101
01111111
NAME Cat (12,11)

TIL 12l
11111101
01111111
11111011
11101111
01111010
11011111
11110101
01111110
NAME Cat (13,11)

TIL 12m
01011111
11101111
01111011
11110111
11011111
01111101
11101111
10111101
NAME Cat (14,11)

TIL 12n
00111101
11111111
11111111
01111110
11011111
11111101
01111111
11101111
NAME Cat (15,11)

TIL 12o
01001111
00111101
01111111
00101111
00011111
01000110
00010110
10100011
NAME Cat (0,12)

TIL 12p
01110101
11010101
10101011
10101110
01010111
10101110
11111101
11111100
NAME Cat (1,12)

TIL 12q
11111111
11111101
11011111
11111011
10111111
11101101
11111111
01111101
NAME Cat (2,12)

TIL 12r
11101110
10111010
11111110
11111100
11111100
11111101
11111111
11111011
NAME Cat (3,12)

TIL 12s
01111011
10010110
00100111
10100111
01001111
11010111
11001101
11011111
NAME Cat (4,12)

TIL 12t
11111111
10110111
11111101
11011111
01010111
01010101
10101010
11010101
NAME Cat (5,12)

TIL 12u
01011100
01011101
11111110
10111111
11111111
11111111
11111011
01111110
NAME Cat (6,12)

TIL 12v
11111100
00111011
10001100
01111011
11011011
11101100
11101011
10101010
NAME Cat (7,12)

TIL 12w
10010000
01111101
11111100
11111010
11110001
10100100
01010111
10111011
NAME Cat (8,12)

TIL 12x
01111111
00111111
10101111
01111111
00111111
10011111
01011111
00011110
NAME Cat (9,12)

TIL 12y
11101111
11111111
11111110
11111101
11111010
11111010
11111111
11101101
NAME Cat (10,12)

TIL 12z
01110101
11011111
00100100
01011011
10110101
01101010
11110101
11111000
NAME Cat (11,12)

TIL 13a
10111111
11111011
11111101
11110110
01111000
00110101
10110000
00101011
NAME Cat (6,13)

TIL 13b
11101011
01101011
11010101
00111011
10101010
00111111
11110101
11101110
NAME Cat (7,13)

TIL 13c
01001111
11101111
01111111
10111111
11011111
01101111
11011011
11111111
NAME Cat (8,13)

TIL 13d
01111111
00111010
01111111
11110101
11111011
11110111
11111111
11111111
NAME Cat (9,13)

TIL 13e
01110111
11101101
11111110
11010101
11111111
11101011
11110111
11011110
NAME Cat (10,13)

TIL 13f
10111110
11011111
10110111
11111110
11010111
01111111
10101101
11111111
NAME Cat (11,13)

TIL 13g
11111111
11011111
11111111
11010111
11111011
11010101
10111110
01101111
NAME Cat (12,13)

TIL 13h
11011111
01111111
11111111
10111111
11110111
10111111
11111110
10111101
NAME Cat (13,13)

TIL 13i
11110011
01111011
11111111
01111111
11111111
11101110
10111111
00100110
NAME Cat (14,13)

TIL 13j
11101011
11101011
11110111
10101111
10101111
10011111
01010001
10111011
NAME Cat (15,13)

TIL 13k
01001101
00101100
11111111
10111111
11011111
11000111
11101011
01010100
NAME Cat (0,14)

TIL 13l
00110001
11010100
01100010
11011001
11110011
11010111
11111111
11111111
NAME Cat (1,14)

TIL 13m
01010110
11001011
11010001
11000101
11101001
10110010
01101000
11011110
NAME Cat (2,14)

TIL 13n
00100110
11111101
11111101
11111101
11111101
11111101
11111101
10111111
NAME Cat (3,14)

TIL 13o
11011010
00101001
01010110
01001111
01010011
10101011
11010111
11101010
NAME Cat (4,14)

TIL 13p
10011111
01011000
10101010
10100001
11101001
11111111
11111010
11111111
NAME Cat (5,14)

TIL 13q
11101111
10011111
01100011
01101001
10100010
11111000
11111101
11101111
NAME Cat (6,14)

TIL 13r
10111011
11101111
10110111
11011111
11111111
11111111
11111111
01111111
NAME Cat (7,14)

TIL 13s
11111111
11111101
11111110
10110111
11111010
11111111
11110110
11011111
NAME Cat (8,14)

TIL 13t
01110110
11011111
10111101
11011110
10111011
11111101
11111111
10111011
NAME Cat (9,14)

TIL 13u
11111101
01111110
11110111
10111101
11111111
01011111
11101111
00101111
NAME Cat (10,14)

TIL 13v
10111110
11011111
01111101
11011111
01111111
11111111
11111111
11111111
NAME Cat (11,14)

TIL 13w
11110111
10101110
01110101
10110100
11111101
11111111
11110001
11101100
NAME Cat (12,14)

TIL 13x
11010100
11101010
01111001
10101010
01011101
11111010
11111111
10111001
NAME Cat (13,14)

TIL 13y
10101010
01101011
01111101
11110100
11110001
11100100
11101001
11111111
NAME Cat (14,14)

TIL 13z
01110101
11111011
11111001
01001101
00100011
10001011
10100001
11101011
NAME Cat (15,14)

TIL 14a
00000011
11010000
11100101
01111111
01111111
10101111
10110110
01011011
NAME Cat (10,15)

TIL 14b
11111111
01111111
11111111
11101111
01111011
10101111
11110101
11111110
NAME Cat (11,15)

TIL 14c
11010010
11010101
11011111
11111111
01111110
11111011
11111111
11111101
NAME Cat (12,15)

TIL 14d
11001101
10101010
01011010
00111101
10101111
01111111
11011111
11111111
NAME Cat (13,15)

TIL 14e
11111111
01111111
11111111
01111111
11111110
11111001
11111100
11111001
NAME Cat (14,15)

TIL 14f
11110101
11111111
11111111
11111111
00111111
01101011
00110001
01101010
NAME Cat (15,15)

TIL 14g
00000000
01101111
00101000
01010101
01010101
01010101
01010010
01001010
NAME Forest2 (0,0)

TIL 14h
00000000
10111110
10100010
01010101
01010101
01010101
10101010
10010101
NAME Forest2 (1,0)

TIL 14i
00000000
11111011
10001010
01010101
01010101
01010101
10101010
00100101
NAME Forest2 (2,0)

TIL 14j
00000000
11101111
00101000
01010101
01010101
01010101
10101010
01001001
NAME Forest2 (3,0)

TIL 14k
00000000
10111110
10100010
01010101
01010101
01010101
10101010
01010100
NAME Forest2 (4,0)

TIL 14l
00000000
11111011
10001010
01010101
01010101
01010101
10101010
10010101
NAME Forest2 (5,0)

TIL 14m
00000000
10111110
10100010
01010101
01010101
00101010
10101001
01010101
NAME Forest2 (13,0)

TIL 14n
00000000
11111011
10001010
01010101
01010101
10101010
01010100
00101010
NAME Forest2 (14,0)

TIL 14o
00000000
11101110
00101001
01010100
01010101
10101010
10100101
10010100
NAME Forest2 (15,0)

TIL 14p
01010101
01010101
01010101
01010100
00101010
01010101
01010010
01010101
NAME Forest2 (0,1)

TIL 14q
01010010
01010101
01010101
10101010
10100101
01010101
10101010
01010101
NAME Forest2 (1,1)

TIL 14r
10101010
01010101
01010101
10101010
01010101
00101001
10100101
01010101
NAME Forest2 (2,1)

TIL 14s
01010101
01010101
01010101
10101010
01010101
00101010
01010010
01010101
NAME Forest2 (3,1)

TIL 14t
00100101
01010101
01010101
10101010
01010101
01001010
10101001
01010101
NAME Forest2 (4,1)

TIL 14u
01010010
01010101
01010101
10101010
01010101
10010010
01010101
01010101
NAME Forest2 (5,1)

TIL 14v
01010101
01010101
01010101
10101010
01010101
01001010
01010100
01010101
NAME Forest2 (6,1)

TIL 14w
00100101
01010101
01010101
10101010
01010101
10010010
10101010
01010101
NAME Forest2 (7,1)

TIL 14x
01010010
01010101
01010101
10101010
01010101
10100100
01010101
01010101
NAME Forest2 (8,1)

TIL 14y
01010101
01010101
01010101
10101010
01010101
10101001
01001010
01010101
NAME Forest2 (9,1)

TIL 14z
00100101
01010101
01010101
10101010
01010101
00101010
10100101
01010101
NAME Forest2 (10,1)

TIL 15a
10101010
01010101
10100100
10010101
01010101
00101010
10101010
01010101
NAME Forest2 (5,2)

TIL 15b
10101010
01010010
10101010
01010101
01001010
10101010
01010101
01010101
NAME Forest2 (6,2)

TIL 15c
10101010
10100101
10010101
01010101
10101010
01010111
01010101
01011110
NAME Forest2 (7,2)

TIL 15d
10101010
01010101
00101010
01111110
11101011
10111111
11101010
10111111
NAME Forest2 (8,2)

TIL 15e
10101010
01010101
10101010
10011111
01110101
10111111
11101011
10111110
NAME Forest2 (9,2)

TIL 15f
10101010
01010101
10101111
01011010
01111111
01010101
11111111
11010101
NAME Forest2 (10,2)

TIL 15g
10111011
01110110
11011111
11110101
10111111
11010101
01111111
11011010
NAME Forest2 (11,2)

TIL 15h
10101010
11010101
10101010
11101001
01110101
10101010
11111010
10101011
NAME Forest2 (12,2)

TIL 15i
10101010
01010101
10010010
01010101
01010101
10101010
01010010
01001010
NAME Forest2 (13,2)

TIL 15j
10101010
01001001
10101010
01010101
00101010
10101001
10101010
10101010
NAME Forest2 (14,2)

TIL 15k
10101010
01010101
10101010
01010010
10010101
01010100
10101010
10101010
NAME Forest2 (15,2)

TIL 15l
01010101
01001010
01010101
01010100
01010101
00101010
01010101
01010010
NAME Forest2 (0,3)

TIL 15m
01010011
10101010
01010101
10010100
01010101
10101010
01010001
10101010
NAME Forest2 (1,3)

TIL 15n
00101010
10100101
01010101
10001010
01010101
10101010
01010100
10100101
NAME Forest2 (2,3)

TIL 15o
01010101
01001001
01010100
10101010
01010101
10101010
10010101
01010010
NAME Forest2 (3,3)

TIL 15p
01001010
01010101
10101010
00101001
10010101
01001010
01101000
10010101
NAME Forest2 (4,3)

TIL 15q
10101010
01010010
10010101
01010101
01010101
10101010
10010101
01010010
NAME Forest2 (5,3)

TIL 15r
10101010
10100101
01010100
00101010
01010101
10101110
01011011
10111110
NAME Forest2 (6,3)

TIL 15s
10101011
01001110
10101011
10111110
01010111
10111011
11101101
10111111
NAME Forest2 (7,3)

TIL 15t
11101101
11111110
10101011
11111110
01010111
11111010
01011111
11101010
NAME Forest2 (8,3)

TIL 15u
11101011
10111110
11101111
10111010
11101111
10111010
11101111
10111010
NAME Forest2 (9,3)

TIL 15v
10111111
11110110
10111101
11101111
10111010
11101111
10111010
11101111
NAME Forest2 (10,3)

TIL 15w
01111111
11101010
11011111
11110101
10111111
11010101
11111111
01010101
NAME Forest2 (11,3)

TIL 15x
11111101
10101110
11110111
01011011
11111110
01010111
11111101
01101111
NAME Forest2 (12,3)

TIL 15y
10101010
10101010
01010101
10101010
10101001
01010101
10101010
11110101
NAME Forest2 (13,3)

TIL 15z
01010101
10101010
01010100
10100101
01010101
00101010
10101001
01010101
NAME Forest2 (14,3)

TIL 16a
11101111
10111010
11101111
11111010
10101111
11111011
10111110
11101111
NAME Forest2 (9,4)

TIL 16b
10111011
11101101
10111111
11101011
10111111
11101111
11111101
11110110
NAME Forest2 (10,4)

TIL 16c
11111111
01010101
11111111
11101101
01111111
10110110
11011111
10110101
NAME Forest2 (11,4)

TIL 16d
10111011
11111110
01010111
11111101
10110111
11111110
11011011
01111110
NAME Forest2 (12,4)

TIL 16e
01011110
11101011
10111111
11111111
10101101
11111110
11101011
10111101
NAME Forest2 (13,4)

TIL 16f
10101010
01010101
01001010
00101001
10101010
10101010
10010101
10101010
NAME Forest2 (14,4)

TIL 16g
10101010
01010101
10010010
01010101
10101010
10101010
01010101
10101000
NAME Forest2 (15,4)

TIL 16h
01010101
01010101
01001010
01010101
01010100
01010101
00101010
01010101
NAME Forest2 (0,5)

TIL 16i
01001010
00101010
10100010
01010001
10100100
00101010
01010101
01010100
NAME Forest2 (1,5)

TIL 16j
10100000
01000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Forest2 (2,5)

TIL 16k
01000101
01010101
00101010
00010001
00001000
00010001
00001001
00010101
NAME Forest2 (3,5)

TIL 16l
01001010
01010101
10101010
01010101
10101010
01010100
01001010
01010101
NAME Forest2 (4,5)

TIL 16m
00101011
10010110
10101111
01011010
10101111
10110101
10111111
01010101
NAME Forest2 (5,5)

TIL 16n
10101111
11111011
10101110
11111011
10111110
11101011
01111110
11010111
NAME Forest2 (6,5)

TIL 16o
01110101
11011111
11110101
10111110
11010111
11111010
10101111
11111011
NAME Forest2 (7,5)

TIL 16p
01010111
11111110
10101111
11111111
10111111
11111111
10111111
11111111
NAME Forest2 (8,5)

TIL 16q
01111010
11011111
11101101
11111111
11111101
11011111
11101010
10111111
NAME Forest2 (9,5)

TIL 16r
10101111
11111010
01010111
10111101
01101111
11110101
10111110
11010101
NAME Forest2 (10,5)

TIL 16s
11101111
10111010
11111111
11111110
01111111
11111111
11111110
11111111
NAME Forest2 (11,5)

TIL 16t
11101011
10111101
11010111
11111010
01010111
11111101
10101111
11110111
NAME Forest2 (12,5)

TIL 16u
11010111
01111101
10101110
11111110
10111111
11111110
11111111
11111111
NAME Forest2 (13,5)

TIL 16v
01001001
10101010
10010101
01010101
00100101
10100101
01010010
10101010
NAME Forest2 (14,5)

TIL 16w
01010110
10010010
01010101
01010100
01010101
00101010
10101010
10101001
NAME Forest2 (15,5)

TIL 16x
01010010
01010101
01010101
00100100
00010010
01101010
01010101
00101010
NAME Forest2 (0,6)

TIL 16y
10101011
01010100
01001010
10101001
00010010
11010101
00101010
10101001
NAME Forest2 (1,6)

TIL 16z
00000000
10000000
10100000
01000010
00101001
01010101
10101010
01010101
NAME Forest2 (2,6)

TIL 17a
10100101
10101010
01010101
01001000
00100101
01010100
10101010
01010101
NAME Forest2 (15,6)

TIL 17b
00000000
01010101
00000000
01011011
00000000
00101001
00000010
01001000
NAME Forest2 (0,7)

TIL 17c
00000100
01010001
00000100
01101010
00000000
01010101
00000000
01001010
NAME Forest2 (1,7)

TIL 17d
00000000
01010101
00000000
11011011
00000000
01001010
00010000
01000010
NAME Forest2 (2,7)

TIL 17e
00100100
00000010
01010000
01010110
00000001
10010100
00100000
10000101
NAME Forest2 (3,7)

TIL 17f
10000000
00101010
10000000
01011010
00000000
01001010
00100000
00001010
NAME Forest2 (4,7)

TIL 17g
10110111
00111010
10101111
11011011
11111101
10101111
01110101
00010111
NAME Forest2 (5,7)

TIL 17h
10101101
11111110
01011011
11111111
11111111
01111111
11111111
11111111
NAME Forest2 (6,7)

TIL 17i
11011101
11110111
11011101
11111111
11111101
11111111
11111110
11111111
NAME Forest2 (7,7)

TIL 17j
01010101
10111111
01101010
11111111
01010101
11101110
10111011
11111110
NAME Forest2 (8,7)

TIL 17k
10111111
01101010
11111101
10101011
11111110
10101011
11011101
10110111
NAME Forest2 (9,7)

TIL 17l
10101111
11110111
10111101
11010111
11111111
11111111
11111111
11111111
NAME Forest2 (10,7)

TIL 17m
11111111
11111111
11111000
11111111
11111100
11111000
11110001
11000000
NAME Forest2 (13,7)

TIL 17n
11101000
11000010
00101000
10100101
00001000
01000010
00010001
01000100
NAME Forest2 (14,7)

TIL 17o
00000000
10101010
00000000
10110110
00000000
01010010
00000100
01010000
NAME Forest2 (15,7)

TIL 17p
00100010
10001000
01000010
11010000
01000100
00100010
11010000
01100101
NAME Forest2 (0,8)

TIL 17q
00100000
10001010
00100000
10001000
00100010
10001000
00100010
00001000
NAME Forest2 (1,8)

TIL 17r
10001000
00100010
10001000
00100010
10000000
00101010
10000000
00100101
NAME Forest2 (2,8)

TIL 17s
00100000
00010100
10000001
01010100
00000001
10100100
00001000
01000010
NAME Forest2 (3,8)

TIL 17t
10100000
00001010
01000000
00010100
01000001
00010100
10000001
00101000
NAME Forest2 (4,8)

TIL 17u
10001011
00100111
10000000
00101000
00000000
01001000
00000000
00000000
NAME Forest2 (5,8)

TIL 17v
11111111
11110001
11110001
01100001
00000000
00000000
00000000
00000000
NAME Forest2 (6,8)

TIL 17w
11111111
11111111
11111111
11111111
00100011
00010101
01000011
00001001
NAME Forest2 (7,8)

TIL 17x
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111101
NAME Forest2 (11,8)

TIL 17y
11111110
11101000
11000010
10101000
00000010
10101000
00000010
01010000
NAME Forest2 (12,8)

TIL 17z
10001010
00100001
10001000
00100010
10001000
00000010
01010000
10001010
NAME Forest2 (13,8)

TIL 18a
11111111
11111111
11111111
01111111
11111111
11111111
11111111
11111111
NAME Forest2 (9,9)

TIL 18b
11101111
11100111
11110111
11110111
11110111
11111111
11111111
11111111
NAME Forest2 (10,9)

TIL 18c
11111100
11111100
11111000
11111001
11101000
11110010
11010001
11100101
NAME Forest2 (11,9)

TIL 18d
00000100
10010010
01001101
00101011
10111101
01010110
01101011
10111010
NAME Forest2 (12,9)

TIL 18e
00100000
11010010
01101000
10110100
01011001
11101010
01011100
11110101
NAME Forest2 (13,9)

TIL 18f
10001010
00100000
10000100
00100010
00001000
01000010
00101000
00000010
NAME Forest2 (14,9)

TIL 18g
00001010
10100101
00001010
10100111
00001001
01010101
10111101
01111111
NAME Forest2 (15,9)

TIL 18h
01100000
11000000
01000000
11100000
01010000
11000010
00010000
00001010
NAME Forest2 (0,10)

TIL 18i
00000111
00000101
00000110
00001011
00100110
10000011
00101100
00001111
NAME Forest2 (1,10)

TIL 18j
01011011
10110110
11101101
10111111
11101010
11111111
01101110
01101111
NAME Forest2 (2,10)

TIL 18k
10111000
11010100
01110100
10111000
11010100
10010010
10100101
00101010
NAME Forest2 (3,10)

TIL 18l
00000000
00000000
00000000
00000000
10100010
10011010
01010101
10101010
NAME Forest2 (4,10)

TIL 18m
00000000
00000000
00000000
00000000
00000001
11010101
00101010
11010111
NAME Forest2 (5,10)

TIL 18n
00010011
01111111
01111011
11101101
11011110
11110101
11011111
11101010
NAME Forest2 (6,10)

TIL 18o
11000100
01101110
10110111
11011101
10110111
11111101
01110110
11111011
NAME Forest2 (7,10)

TIL 18p
00000000
11010101
11100000
11110000
01010000
11100000
10110000
11101000
NAME Forest2 (8,10)

TIL 18q
01111111
00011111
00111111
00001111
00001111
00001111
00000111
00000111
NAME Forest2 (9,10)

TIL 18r
11000101
10010110
00000101
00001010
00000111
00001010
00010111
10101010
NAME Forest2 (11,10)

TIL 18s
01010111
11101101
10110110
11011011
01101110
10111011
01111111
11110111
NAME Forest2 (12,10)

TIL 18t
01011100
11110110
10111101
11010110
11111101
01010110
11111110
11101010
NAME Forest2 (13,10)

TIL 18u
10010001
00001011
00000111
00000011
00000011
00000111
00000111
00001111
NAME Forest2 (14,10)

TIL 18v
00100000
01010101
01010010
10101011
11111111
11111111
11111111
11111111
NAME Forest2 (0,11)

TIL 18w
10110111
00011111
11010111
01111101
11110111
11111011
11111110
11111101
NAME Forest2 (1,11)

TIL 18x
00111110
10111111
11111111
01111111
11111111
01111111
11111111
11111111
NAME Forest2 (2,11)

TIL 18y
10101010
01010101
10100101
10110010
11111000
10101110
11111010
01011111
NAME Forest2 (3,11)

TIL 18z
10100111
11111011
01101101
01011111
00001011
10001010
00000111
01000101
NAME Forest2 (4,11)

TIL 19a
00000011
11000011
10000011
01001001
11000001
00000001
11101001
11110110
NAME Forest2 (4,12)

TIL 19b
11101010
01011111
11110101
10111111
11101011
01111110
11011111
10111111
NAME Forest2 (5,12)

TIL 19c
11111111
01111111
11111111
01011111
11111111
11111111
11111111
11111111
NAME Forest2 (6,12)

TIL 19d
11011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Forest2 (9,12)

TIL 19e
11111111
11111111
11111111
11111110
11110111
11111011
11110110
11111011
NAME Forest2 (14,12)

TIL 19f
11111111
11111111
11111111
11111111
01010110
11111011
10101110
11110111
NAME Forest2 (15,12)

TIL 19g
11111111
11111111
11111111
11111111
10101010
11111111
11101010
11111111
NAME Forest2 (0,13)

TIL 19h
11111111
11111111
11111111
11111111
10101011
11110110
10111101
11010111
NAME Forest2 (1,13)

TIL 19i
11111111
11111111
11111111
11111111
11111110
10101011
11111110
01010101
NAME Forest2 (2,13)

TIL 19j
11111111
11111111
11111110
11111100
10101010
11111001
10110010
11101001
NAME Forest2 (3,13)

TIL 19k
10000001
01010100
00000001
10100100
00010001
01000100
00101001
00000100
NAME Forest2 (4,13)

TIL 19l
00100111
00001111
00010111
01011111
00001111
01000101
00101011
10000101
NAME Forest2 (5,13)

TIL 19m
11111111
01111111
11111111
11111111
11111111
11111111
01011111
11110111
NAME Forest2 (6,13)

TIL 19n
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME Forest2 (13,13)

TIL 19o
11111111
01010101
11111111
11010101
11111011
11110111
11111110
11111111
NAME Forest2 (2,14)

TIL 19p
01110100
11110010
11010101
11010101
11010101
10101010
10100001
11010100
NAME Forest2 (3,14)

TIL 19q
10101000
01000101
01010100
01010101
01010101
10101000
00010110
01001000
NAME Forest2 (4,14)

TIL 19r
01010101
00101011
10100100
01010101
01001010
10100001
10010100
01000010
NAME Forest2 (5,14)

TIL 19s
01011111
11111010
01111111
10101011
01010101
00101011
10010100
01000010
NAME Forest2 (6,14)

TIL 19t
11111111
11111111
01010101
11111011
01010110
10111111
10101011
01011110
NAME Forest2 (7,14)

TIL 19u
11111111
11111111
01111111
11010111
11111010
01011111
11101011
10111101
NAME Forest2 (8,14)

TIL 19v
11111111
11111111
11111111
11111110
11011011
01110110
11011111
01110101
NAME Forest2 (9,14)

TIL 19w
11111111
11111111
11111111
10101011
11110111
10111111
11011111
01101111
NAME Forest2 (10,14)

TIL 19x
10111111
11111111
10111111
11111111
11111111
11011111
11111111
11111111
NAME Forest2 (13,14)

TIL 19y
01100010
11011001
11101010
11101010
11110101
11111101
11111011
11111111
NAME Forest2 (3,15)

TIL 19z
10010010
00100100
10010011
01011011
10111111
01111111
11111111
11111111
NAME Forest2 (4,15)

TIL 1a0
10010100
01010010
01010101
10101010
11101010
11111010
11111111
11111111
NAME Forest2 (5,15)

TIL 1a1
10010001
10101010
00000001
10101010
10101001
10101010
10101010
11111010
NAME Forest2 (6,15)

TIL 1a2
00111111
01001111
00101011
01010101
00101010
10101010
10101010
10101010
NAME Forest2 (7,15)

TIL 1a3
11010111
11111011
11101111
01011111
10101111
10101001
10101111
11011111
NAME Forest2 (8,15)

TIL 1a4
10111111
01101010
11110111
11111110
11111111
11111111
11111111
11111111
NAME Forest2 (9,15)

TIL 1a5
10111111
11101111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Forest2 (10,15)

TIL 1a6
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME Sparkle

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
POS 1 3,10

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME cat
DLG 0
POS 1 11,9

SPR b
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME Cat1
DLG 6
POS 2 12,11

SPR c
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME Cat3
DLG 7
POS 3 11,12

SPR d
00000000
00011000
00011000
01111110
10111101
00111100
00111100
00100100
NAME Dad
DLG 8
POS 4 5,9

SPR e
00000000
00011000
00011000
00111100
01011010
10111101
00111100
00100100
NAME Mum
DLG a
POS 4 8,8

SPR f
00000000
00000000
00001110
00011011
00011000
00111100
00011000
00100100
NAME Sister
DLG 9
POS 4 13,8

SPR g
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME CatOuterworld
DLG e
POS 6 5,13

SPR h
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME CliffCat
DLG 5
POS 7 8,7

SPR i
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME Cat4
DLG b
POS 5 12,10

ITM 0
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME TV
DLG 1

ITM 1
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME key

ITM 2
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME Bedroom
DLG 4

ITM 3
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME LivingRoomSparkle
DLG c

ITM 4
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME LivingRoomSparkle2
DLG d

ITM 5
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME LivingRoom3

ITM 6
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME SparkleCliff

ITM 7
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME SparkleCliff2

ITM 8
00000000
00100000
01110000
00100000
00000100
00001110
00000100
00000000
>
00000000
00000100
00001110
00000100
00100000
01110000
00100000
00000000
NAME OuterWorldSparkle
DLG f

DLG 0
"""
Hello lil miss,
I know this all might seem bizarre.
You might ask, where am I?
But don't worry because I, your guardian feline, will help you through. 
Why don't we start at the beginning? 
To the door just behind you
Where everything fell apart. . .

"""
NAME cat dialog

DLG 1
Then where am I?{exit "6" 1 13 "wave"}... Huh? What?
NAME TV dialog

DLG 3

NAME Sister dialog

DLG 4
"""
I guess Ive been numb for the last year. . .
Throwing myself into games, sleeping, books.
Anything to not think of {shk}that{shk}. 
I have been walking in a daze, I think. 
{exit "c" 2 7 "fade_b"}H-how did I get down here?
Where is everyone?
"""
NAME Bedroom dialog

DLG 5
{end}... blub
NAME CliffCat dialog

DLG 6
"""
Do you remember this tree?
Where your grandpa died . . .
well . . .
it must be hard when everyone tip toes around such matters.
It must leave you feeling quite alone. 
But let us not do that here, let us say it how it is:
Died by suicide. 
I'm awfully sorry for your loss . . . 
But it's also why I'm here. 
Let's go on a journey, you and me.
"""
NAME Cat1 dialog

DLG 7
"""
You've locked these memories away.
So far, far back into your mind. 

They must be distressing for you,
Or else we would not be here now. 
How does this all make you feel?
Revisiting your past . . . 
"""
NAME Cat3 dialog

DLG 8
"""
Oh honey, you're down from your room.
Today at work I- 

"""
NAME Dad dialog

DLG 9
"""
You don't look so okay sissy. . .

Is everything okay? 

Mum and Dad havent been speaking recently and sissy I'm scared.
What is going on?
Can you tell me?
"""
NAME Sister dialog 1

DLG a
*Mum sniffles quietly to herself*
NAME Mum dialog

DLG b
"""
Avoidance. Anguish. Fear. 
Your family are all in grief. 
But you aren't able to talk to them about it, are you? 

"""
NAME Cat4 dialog

DLG c
"""
I guess everyone is gone. 
Mum . . . Dad . . . 
Did they finally leave me like Grandpa did? 

"""
NAME LivingRoomSparkle dialog

DLG d
They wouldn't leave me . . . they wouldn't . . . 
NAME LivingRoomSparkle2 dialog

DLG e
"""
Don't be afraid lil miss.
Doesn't this place look familiar to you? 
It's the world you've created.
The one you've hidden in for so long. 
Do you know why you hid here?

"""
NAME CatOuterworld dialog

DLG f
"""
It was all so overwhelming when Grandpa died
I didn't know what to do . . . who to turn to.
Everyone had shut me out, so I shut down inside myself.
I shut everything off.

"""
NAME OuterWorldSparkle dialog

VAR a
42


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1)
	attachCanvas(gameCanvas);
	loadGame(gameData, defaultFontData);
}
</script>

<script>
/* logging */
var DebugLogCategory = {
	system: false,
	bitsy : false,
	editor : false,
};

var isLoggingVerbose = false;

/* input */
var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function isRestartCombo(e) {
		return (e.keyCode === key.r && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === key.up || key === key.down || key === key.left || key === key.right) &&
				!(key === key.w || key === key.s || key === key.a || key === key.d)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;
}

var input = new InputManager();

/* events */
var onLoadFunction = null;
var onQuitFunction = null;
var onUpdateFunction = null;
var updateInterval = null;

function initSystem() {
	// temp hack for the editor? unless??
	drawingBuffers[screenBufferId] = createDrawingBuffer(width, height, scale);
	drawingBuffers[textboxBufferId] = createDrawingBuffer(0, 0, textScale);
}

function loadGame(gameData, defaultFontData) {
	drawingBuffers[screenBufferId] = createDrawingBuffer(width, height, scale);
	drawingBuffers[textboxBufferId] = createDrawingBuffer(0, 0, textScale);

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart, {passive:false});
		canvas.addEventListener('touchmove', input.ontouchmove, {passive:false});
		canvas.addEventListener('touchend', input.ontouchend, {passive:false});
	}
	else {
		// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

		// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
		var existingTouchTrigger = document.querySelector('#touchTrigger');

		if (existingTouchTrigger === null) {
			var touchTrigger = document.createElement("div");
			touchTrigger.setAttribute("id","touchTrigger");

			// afaik css in js is necessary here to force a fullscreen element
			touchTrigger.setAttribute(
				"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
			);

			document.body.appendChild(touchTrigger);

			touchTrigger.addEventListener('touchstart', input.ontouchstart);
			touchTrigger.addEventListener('touchmove', input.ontouchmove);
			touchTrigger.addEventListener('touchend', input.ontouchend);
		}
	}

	window.onblur = input.onblur;

	if (onLoadFunction) {
		// todo : is this the right place to supply default font data?
		onLoadFunction(gameData, defaultFontData);
	}

	updateInterval = setInterval(
		function() {
			if (onUpdateFunction) {
				onUpdateFunction();
			}

			renderGame();

			input.resetTapReleased();

			if (bitsyGetButton(5)) {
				if (confirm("Restart the game?")) {
					input.resetAll();
					reset_cur_game();
				}

				return;
			}
		},
		16);
}

function renderGame() {
	// bitsyLog("render game mode=" + curGraphicsMode, "system");

	bitsyLog(systemPalette.length, "system");

	var startIndex = curGraphicsMode === 0 ? screenBufferId : (drawingBuffers.length - 1);

	for (var i = startIndex; i >= 0; i--) {
		var buffer = drawingBuffers[i];
		if (buffer && buffer.canvas === null) {
			bitsyLog("render buffer " + i, "system");
			renderDrawingBuffer(i, buffer);
		}
	}

	// show screen buffer
	var screenBuffer = drawingBuffers[screenBufferId];
	ctx.drawImage(
		screenBuffer.canvas,
		0,
		0,
		screenBuffer.width * screenBuffer.scale,
		screenBuffer.height * screenBuffer.scale);
}

function quitGame() {
	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		//check for touchTrigger and removes it

		var existingTouchTrigger = document.querySelector('#touchTrigger');

		if (existingTouchTrigger !== null) {
			existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
			existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
			existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

			existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
		}
	}

	window.onblur = null;

	if (onQuitFunction) {
		onQuitFunction();
	}

	clearInterval(updateInterval);
}

/* graphics */
var canvas;
var ctx;

var textScale = 2; // todo : move tile scale into here too?

var curGraphicsMode = 0;
var systemPalette = [[0, 0, 0]];
var curBufferId = -1; // note: -1 is invalid
var drawingBuffers = [];

var screenBufferId = 0;
var textboxBufferId = 1;
var tileStartBufferId = 2;
var nextBufferId = tileStartBufferId;

var DrawingInstruction = {
	Pixel : 0,
	Tile : 1,
	Clear : 2,
	Textbox : 3,
	PixelIndex : 4,
};

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
}

function createDrawingBuffer(width, height, scale) {
	var buffer = {
		width : width,
		height : height,
		scale : scale, // logical-pixel to display-pixel scale
		instructions : [], // drawing instructions
		canvas : null,
	}

	return buffer;
}

function renderPixelInstruction(bufferId, buffer, paletteIndex, x, y) {
	if (bufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	if (!systemPalette[paletteIndex]) {
		// bitsyLog("invalid index " + paletteIndex + " @ " + x + "," + y, "system");
		return;
	}

	var color = systemPalette[paletteIndex];

	if (buffer.imageData) {
		for (var sy = 0; sy < buffer.scale; sy++) {
			for (var sx = 0; sx < buffer.scale; sx++) {
				var pixelIndex = (((y * buffer.scale) + sy) * buffer.width * buffer.scale * 4) + (((x * buffer.scale) + sx) * 4);

				buffer.imageData.data[pixelIndex + 0] = color[0];
				buffer.imageData.data[pixelIndex + 1] = color[1];
				buffer.imageData.data[pixelIndex + 2] = color[2];
				buffer.imageData.data[pixelIndex + 3] = 255;
			}
		}
	}
	else {
		var bufferContext = buffer.canvas.getContext("2d");
		bufferContext.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
		bufferContext.fillRect(x * buffer.scale, y * buffer.scale, buffer.scale, buffer.scale);
	}
}

function renderPixelAtIndexInstruction(bufferId, buffer, paletteIndex, index) {
	if (bufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	if (!systemPalette[paletteIndex]) {
		// bitsyLog("invalid index " + paletteIndex + " @ " + x + "," + y, "system");
		return;
	}

	var color = systemPalette[paletteIndex];

	if (buffer.imageData) {
		for (var sy = 0; sy < buffer.scale; sy++) {
			for (var sx = 0; sx < buffer.scale; sx++) {
				var pixelIndex = index * 4;

				buffer.imageData.data[pixelIndex + 0] = color[0];
				buffer.imageData.data[pixelIndex + 1] = color[1];
				buffer.imageData.data[pixelIndex + 2] = color[2];
				buffer.imageData.data[pixelIndex + 3] = 255;
			}
		}
	}
	else {
		var y = Math.floor(index / buffer.width);
		var x = index - (y * buffer.width);
		var bufferContext = buffer.canvas.getContext("2d");
		bufferContext.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
		bufferContext.fillRect(x * buffer.scale, y * buffer.scale, buffer.scale, buffer.scale);
	}
}

function renderTileInstruction(bufferId, buffer, tileId, x, y) {
	if (bufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	if (!drawingBuffers[tileId]) {
		return;
	}

	var tileBuffer = drawingBuffers[tileId];

	var bufferContext = buffer.canvas.getContext("2d");
	bufferContext.drawImage(
		tileBuffer.canvas,
		x * tilesize * buffer.scale,
		y * tilesize * buffer.scale,
		tilesize * buffer.scale,
		tilesize * buffer.scale);
}

function renderClearInstruction(bufferId, buffer, paletteIndex) {
	var color = systemPalette[paletteIndex];
	var bufferContext = buffer.canvas.getContext("2d");
	bufferContext.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
	bufferContext.fillRect(0, 0, buffer.canvas.width, buffer.canvas.height);
}

function renderTextboxInstruction(bufferId, buffer, x, y) {
	if (bufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	if (!drawingBuffers[textboxBufferId]) {
		return;
	}

	var textboxBuffer = drawingBuffers[textboxBufferId];

	var bufferContext = buffer.canvas.getContext("2d");
	bufferContext.drawImage(
		textboxBuffer.canvas,
		x * buffer.scale,
		y * buffer.scale,
		textboxBuffer.canvas.width,
		textboxBuffer.canvas.height);
}

function renderDrawingBuffer(bufferId, buffer) {
	// bitsyLog("render buffer " + bufferId, "system");

	// if (bufferId === 0) {
	// 	bitsyLog("instructions " + buffer.instructions.length, "system");
	// }

	buffer.canvas = document.createElement("canvas");
	buffer.canvas.width = buffer.width * buffer.scale;
	buffer.canvas.height = buffer.height * buffer.scale;

	for (var i = 0; i < buffer.instructions.length; i++) {
		var instruction = buffer.instructions[i];
		switch (instruction.type) {
			case DrawingInstruction.Pixel:
				renderPixelInstruction(bufferId, buffer, instruction.id, instruction.x, instruction.y);
				break;
			case DrawingInstruction.Tile:
				renderTileInstruction(bufferId, buffer, instruction.id, instruction.x, instruction.y);
				break;
			case DrawingInstruction.Clear:
				renderClearInstruction(bufferId, buffer, instruction.id);
				break;
			case DrawingInstruction.Textbox:
				renderTextboxInstruction(bufferId, buffer, instruction.x, instruction.y);
				break;
			case DrawingInstruction.PixelIndex:
				renderPixelAtIndexInstruction(bufferId, buffer, instruction.id, instruction.index);
		}
	}

	if (buffer.imageData) {
		var bufferContext = buffer.canvas.getContext("2d");
		bufferContext.putImageData(buffer.imageData, 0, 0);
	}
}

function invalidateDrawingBuffer(buffer) {
	buffer.canvas = null;
}

function hackForEditor_GetImageFromTileId(tileId) {
	if (tileId === undefined || !drawingBuffers[tileId]) {
		bitsyLog("editor hack::invalid tile id!", "system");
		return null;
	}

	// force render the buffer if it hasn't been
	if (drawingBuffers[tileId].canvas === null) {
		renderDrawingBuffer(tileId, drawingBuffers[tileId]);
	}

	return drawingBuffers[tileId].canvas;
}

/* ==== */
function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

function bitsyGetButton(buttonCode) {
	switch (buttonCode) {
		case 0: // UP
			return (input.isKeyDown(key.up) || input.isKeyDown(key.w) || input.swipeUp());
		case 1: // DOWN
			return (input.isKeyDown(key.down) || input.isKeyDown(key.s) || input.swipeDown());
		case 2: // LEFT
			return (input.isKeyDown(key.left) || input.isKeyDown(key.a) || input.swipeLeft());
		case 3: // RIGHT
			return ((input.isKeyDown(key.right) || input.isKeyDown(key.d) || input.swipeRight()));
		case 4: // OK (equivalent to "any key" on the keyboard or "tap" on touch screen)
			return (input.anyKeyDown() || input.isTapReleased());
		case 5: // MENU / RESTART (restart the game: "ctrl+r" on keyboard, no touch control yet)
			return input.isRestartComboPressed();
	}

	return false;
}

// two modes (0 == pixel mode, 1 == tile mode)
function bitsySetGraphicsMode(mode) {
	curGraphicsMode = mode;

	var screenBuffer = drawingBuffers[screenBufferId];
	if (curGraphicsMode === 0) {
		screenBuffer.imageData = ctx.createImageData(screenBuffer.width * screenBuffer.scale, screenBuffer.height * screenBuffer.scale);
	}
	else {
		screenBuffer.imageData = undefined;
	}
}

function bitsySetColor(paletteIndex, r, g, b) {
	systemPalette[paletteIndex] = [r, g, b];

	// invalidate all drawing buffers
	for (var i = 0; i < drawingBuffers.length; i++) {
		if (drawingBuffers[i]) {
			invalidateDrawingBuffer(drawingBuffers[i]);
		}
	}
}

function bitsyResetColors() {
	systemPalette = [[0, 0, 0]];

	// invalidate all drawing buffers
	for (var i = 0; i < drawingBuffers.length; i++) {
		if (drawingBuffers[i]) {
			invalidateDrawingBuffer(drawingBuffers[i]);
		}
	}
}

function bitsyDrawBegin(bufferId) {
	curBufferId = bufferId;
	var buffer = drawingBuffers[curBufferId];
	invalidateDrawingBuffer(buffer);
}

function bitsyDrawEnd() {
	curBufferId = -1;
}

function bitsyDrawPixel(paletteIndex, x, y) {
	if (curBufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	// avoid trying to render out-of-bounds colors
	if (paletteIndex >= systemPalette.length) {
		bitsyLog("invalid color! " + paletteIndex, "system");
		paletteIndex = systemPalette.length - 1;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.Pixel, id: paletteIndex, x: x, y: y, });
}

// todo : name is too long :(
// todo : merge with function above?
function bitsySetPixelAtIndex(paletteIndex, pixelIndex) {
	if (curBufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	// avoid trying to render out-of-bounds colors
	if (paletteIndex >= systemPalette.length) {
		bitsyLog("invalid color! " + paletteIndex, "system");
		paletteIndex = systemPalette.length - 1;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.PixelIndex, id: paletteIndex, index: pixelIndex, });
}

function bitsyDrawTile(tileId, x, y) {
	if (curBufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.Tile, id: tileId, x: x, y: y, });
}

function bitsyDrawTextbox(x, y) {
	if (curBufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.Textbox, x: x, y: y, });
}

function bitsyClear(paletteIndex) {
	// avoid trying to render out-of-bounds colors
	if (paletteIndex >= systemPalette.length) {
		paletteIndex = systemPalette.length - 1;
	}

	drawingBuffers[curBufferId].instructions = []; // reset instructions
	drawingBuffers[curBufferId].instructions.push({ type: DrawingInstruction.Clear, id: paletteIndex, });
}

// allocates a tile buffer and returns the ID
function bitsyAddTile() {
	var tileBufferId = nextBufferId;
	nextBufferId++;

	drawingBuffers[tileBufferId] = createDrawingBuffer(tilesize, tilesize, scale);

	return tileBufferId;
}

// clears all tile buffers
function bitsyResetTiles() {
	bitsyLog("RESET TILES", "system");
	// bitsyLog(drawingBuffers, "system");
	// bitsyLog(tileStartBufferId, "system");
	// bitsyLog(drawingBuffers.slice(tileStartBufferId), "system");
	drawingBuffers = drawingBuffers.slice(0, tileStartBufferId);
}

// note: width and height are in text scale pixels
function bitsySetTextboxSize(w, h) {
	drawingBuffers[textboxBufferId] = createDrawingBuffer(w, h, textScale);
}

function bitsyOnLoad(fn) {
	onLoadFunction = fn;
}

function bitsyOnQuit(fn) {
	onQuitFunction = fn;
}

function bitsyOnUpdate(fn) {
	onUpdateFunction = fn;
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsyLog("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		// todo : shouldn't need to set this every frame!
		bitsySetGraphicsMode(0);

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsyLog("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsyDrawBegin(0);
			for (var y = 0; y < height; y++) {
				for (var x = 0; x < width; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsyDrawPixel(color, x, y);
				}
			}
			bitsyDrawEnd();

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < width * height; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < tilesize; y++) {
				for (var x = 0; x < tilesize; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * tilesize) + y) * width) + ((tx * tilesize) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = width;
	this.Height = height;

	this.GetPixel = function(x, y) {
		return imageData[(y * width) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// bitsyLog("COMPILE");
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsyLog("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	// TODO : add back in if needed later...
	// this.CompatibilityParse = function(scriptStr, compatibilityFlags) {
	// 	env.compatibilityFlags = compatibilityFlags;

	// 	var result = parser.Parse(scriptStr);

	// 	delete env.compatibilityFlags;

	// 	return result;
	// }

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsyLog("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptyPrintFunc = function() {
		return new FuncNode("print", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsyLog("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function printFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsyLog("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function printDrawingFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite[spriteId] != undefined) spriteId = names.sprite[spriteId]; // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile[tileId] != undefined) tileId = names.tile[tileId]; // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item[itemId] != undefined) itemId = names.item[itemId]; // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsyLog("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	onReturn(null);
}

function exitFunc(environment,parameters,onReturn) {
	var destRoom = parameters[0];

	if (names.room[destRoom] != undefined) {
		// it's a name, not an id! (note: these could cause trouble if people names things weird)
		destRoom = names.room[destRoom];
	}

	var destX = parseInt(parameters[1]);
	var destY = parseInt(parameters[2]);

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		// update world state
		player().room = destRoom;
		player().x = destX;
		player().y = destY;
		curRoom = destRoom;

		// update game state
		initRoom(curRoom);

		// resume dialog script
		onReturn(null);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsyLog("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsyLog("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsyLog("EVAL EQUAL");
	// bitsyLog(left);
	// bitsyLog(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};
	functionMap["print"] = printFunc;
	functionMap["say"] = printFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["item"] = itemFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["wvy"] = wavyFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["printSprite"] = printSpriteFunc;
	functionMap["printTile"] = printTileFunc;
	functionMap["printItem"] = printItemFunc;
	functionMap["debugOnlyPrintFont"] = printFontFunc; // DEBUG ONLY
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pg"] = pagebreakFunc;
	functionMap["property"] = propertyFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsyLog("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsyLog("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsyLog(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

var DialogBlockNode = function(doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsyLog("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsyLog(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsyLog("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var CodeBlockNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsyLog("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsyLog(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsyLog("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsyLog("SERIALIZE BLOCK!!!");
		// bitsyLog(depth);
		// bitsyLog(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
var UndefinedNode = function(sourceStr) {
	Object.assign(this, new TreeRelationship());
	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		addOrRemoveTextEffect(environment, "_debug_highlight");
		printFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		addOrRemoveTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

var FuncNode = function(name,args) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsyLog("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsyLog("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsyLog("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var SequenceNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsyLog("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

var CycleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsyLog("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

var ShuffleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
var IfNode = function(conditions, results, isSingleLine) {
	Object.assign(this, new TreeRelationship());
	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsyLog("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	}

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var ConditionPairNode = function(condition, result) {
	Object.assign(this, new TreeRelationship());

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	}

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	}
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return Sym.Else;
	}

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		bitsyLog(scriptStr);
		bitsyLog(state.Source());

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsyLog(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsyLog(str);
			// bitsyLog(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsyLog(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsyLog("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsyLog(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var printNode = new FuncNode("print", [new LiteralNode(curText)]);
				curLineNodeList.push(printNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsyLog("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsyLog("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsyLog("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsyLog(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsyLog("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsyLog("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsyLog("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsyLog(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsyLog("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsyLog("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsyLog("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsyLog(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width / textboxInfo.font_scale;
		var textboxScaleH = textboxInfo.height / textboxInfo.font_scale;
		bitsySetTextboxSize(textboxScaleW, textboxScaleH);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	this.ClearTextbox = function() {
		bitsyDrawBegin(1);
		bitsyClear(textBackgroundIndex);
		bitsyDrawEnd();
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		bitsyDrawBegin(0);

		if (isCentered) {
			// todo : will the height calculations always work?
			bitsyDrawTextbox(textboxInfo.left, ((height / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (mapsize / 2)) {
			// bottom
			bitsyDrawTextbox(textboxInfo.left, (height - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsyDrawTextbox(textboxInfo.left, textboxInfo.top);
		}

		bitsyDrawEnd();
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsyLog("draw arrow!");
		bitsyDrawBegin(1);

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							bitsyDrawPixel(textArrowIndex, left + (x * text_scale) + sx, top + (y * text_scale) + sy);
						}
					}
				}
			}
		}

		bitsyDrawEnd();
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		bitsyDrawBegin(1);

		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		var left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {
				var i = (y * char.width) + x;
				if (charData[i] == 1) {
					// todo : other colors
					bitsySetPixelAtIndex(char.color, ((top + y) * (textboxInfo.width * text_scale)) + (left + x));
				}
			}
		}

		bitsyDrawEnd();

		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer, dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue()) {
			this.DrawNextArrow();
		}

		this.DrawTextbox();

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			onPageFinish();
		}
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsyLog(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsyLog(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		bitsyLog("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsyLog("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsyLog("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsyLog("END DIALOG!");
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsyLog("SET POS");
			// bitsyLog(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// bitsyLog("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsyLog("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsyLog("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		}

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		}
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsyLog("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsyLog("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsyLog(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsyLog("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsyLog(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (this.CurChar() && this.CurChar().isPageBreak) {
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;		
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = {};

function positiveModulo(number, divisor) {
	return ((number % divisor) + divisor) % divisor;
}
var RainbowEffect = function() {
	this.DoEffect = function(char, time) {
		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		char.color = tileColorStartIndex + index;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

var DebugHighlightEffect = function() {
	this.DoEffect = function(char) {
		char.color = tileColorStartIndex;
	}
}
TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer(tilesize) {
// todo : do I need to pass in tilesize? or can I use the global value?

bitsyLog("!!!!! NEW TILE RENDERER");

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsyLog("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col) {
	var tileId = bitsyAddTile();

	var backgroundColor = tileColorStartIndex + 0;
	var foregroundColor = tileColorStartIndex + col;

	bitsyDrawBegin(tileId);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = drawingData[y][x];

			if (px === 1) {
				bitsyDrawPixel(foregroundColor, x, y);
			}
			else {
				bitsyDrawPixel(backgroundColor, x, y);
			}
		}
	}

	bitsyDrawEnd();

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsyLog("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		// bitsyLog("frame render: doesn't exist");
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

this.SetDrawingSource = function(drawingId, drawingData) {
	drawingCache.source[drawingId] = drawingData;
	// TODO : reset render cache for this image
}

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
}

this.ClearCache = function() {
	bitsyResetTiles();
	drawingCache.render = {};
}

} // Renderer()
</script>

<script>
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var titleDialogId = "title";
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
};

function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 7, // major changes
	minor: 12, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;
var width = mapsize * tilesize;
var height = mapsize * tilesize;

var curRoom = "0";

var prevTime = 0;
var deltaTime = 0;

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new TileRenderer(tilesize);

var curGameData = null;
var curDefaultFontData = null;

function load_game(gameData, defaultFontData, startWithTitle) {
	curGameData = gameData; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(gameData);

	if (!isPlayerEmbeddedInEditor && defaultFontData) {
		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData, curDefaultFontData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	bitsyLog("stop GAME!");
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		bitsySetGraphicsMode(1);

		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom(room[curRoom]); // draw world if game has begun
		}
		else {
			clearRoom();
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;
}

var isAnyButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsyGetButton(0) || bitsyGetButton(1) || bitsyGetButton(2) || bitsyGetButton(3) || bitsyGetButton(4);
}

function updateInput() {
	if (dialogBuffer.IsActive()) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if (!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					isIgnoringInput = true;
					curPlayerDirection = Direction.None;
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsyGetButton(0)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsyGetButton(1)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsyGetButton(2)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsyGetButton(3)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection);
			playerHoldToMoveTimer = 500;
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	isAnyButtonHeld = isAnyButtonDown();
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

function movePlayer(direction) {
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		startSpriteDialog(spr /*spriteId*/);
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				curRoom = ext.dest.room;

				initRoom(curRoom);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			curRoom = ext.dest.room;

			initRoom(curRoom);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var textBackgroundIndex = 0;
var textArrowIndex = 1;
var textColorIndex = 2;

// precalculated rainbow colors
var rainbowColorStartIndex = 3;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

// todo : where should this be stored?
var tileColorStartIndex = 16;

function updatePaletteWithTileColors(tileColors) {
	// clear existing colors
	bitsyResetColors();

	// textbox colors
	bitsySetColor(textBackgroundIndex, 0, 0, 0); // black
	bitsySetColor(textArrowIndex, 255, 255, 255); // white
	bitsySetColor(textColorIndex, 255, 255, 255); // white

	// todo : move this to game init?
	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsySetColor(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsySetColor(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	var pal = palette[palId];
	bitsyLog(pal.colors.length, "editor");
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsyLog("init room " + roomId);

	updatePalette(curPal());

	renderer.ClearCache();

	// init exit properties
	for (var i = 0; i < room[roomId].exits.length; i++) {
		room[roomId].exits[i].property = { locked:false };
	}

	// init ending properties
	for (var i = 0; i < room[roomId].endings.length; i++) {
		room[roomId].endings[i].property = { locked:false };
	}

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= mapsize) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= mapsize) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// bitsyLog(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	// flags to keep track of which compatibility conversions
	// need to be applied to this game data
	var compatibilityFlags = {
		convertSayToPrint : false,
		combineEndingsWithDialog : false,
		convertImplicitSpriteDialogIds : false,
	};

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// bitsyLog(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));

				if (versionNumber < 5.0) {
					compatibilityFlags.convertSayToPrint = true;
				}

				if (versionNumber < 7.0) {
					compatibilityFlags.combineEndingsWithDialog = true;
					compatibilityFlags.convertImplicitSpriteDialogIds = true;
				}
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "END" && compatibilityFlags.combineEndingsWithDialog) {
			// parse endings for back compat
			i = parseEnding(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	if (curRoom != null) {
		initRoom(curRoom);
	}

	scriptCompatibility(compatibilityFlags);

	return versionNumber;
}

function scriptCompatibility(compatibilityFlags) {
	if (compatibilityFlags.convertSayToPrint) {
		bitsyLog("CONVERT SAY TO PRINT!");

		var PrintFunctionVisitor = function() {
			var didChange = false;
			this.DidChange = function() { return didChange; };

			this.Visit = function(node) {
				if (node.type != "function") {
					return;
				}

				if (node.name === "say") {
					node.name = "print";
					didChange = true;
				}
			};
		};

		for (dlgId in dialog) {
			var dialogScript = scriptInterpreter.Parse(dialog[dlgId].src);
			var visitor = new PrintFunctionVisitor();
			dialogScript.VisitAll(visitor);
			if (visitor.DidChange()) {
				var newDialog = dialogScript.Serialize();
				if (newDialog.indexOf("\n") > -1) {
					newDialog = '"""\n' + newDialog + '\n"""';
				}
				dialog[dlgId].src = newDialog;
			}
		}
	}
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < mapsize && e.y >= 0 && e.y < mapsize;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < mapsize && e.dest.y >= 0 && e.dest.y < mapsize);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//bitsyLog(id);
		//bitsyLog( spriteStartLocations[id] );
		//bitsyLog(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//bitsyLog(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	var results = scriptUtils.ReadDialogScript(lines,i);
	setTitle(results.script);
	i = results.index;

	i++;

	return i;
}

function parseRoom(lines, i, compatibilityFlags) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsyLog(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				dlg: null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			// compatibility with when endings were stored separate from other dialog
			if (compatibilityFlags.combineEndingsWithDialog) {
				endId = "end_" + endId;
			}

			var endCoords = getCoord(lines[i], 2);
			var end = {
				id : endId,
				x : parseInt(endCoords[0]),
				y : parseInt(endCoords[1])
			};

			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room[name] = id;
		}

		i++;
	}

	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw);

	// update animation info
	tileData.animation.frameCount = renderer.GetFrameCount(tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = lines[i].split(/\s(.+)/)[1];
			names.tile[tileData.name] = id;
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	tile[id] = tileData;

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	bitsyLog(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw);

	// update animation info
	spriteData.animation.frameCount = renderer.GetFrameCount(spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = lines[i].split(/\s(.+)/)[1];
			names.sprite[spriteData.name] = id;
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}

		i++;
	}

	// store sprite data
	sprite[id] = spriteData;

	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw);

	// update animation info
	itemData.animation.frameCount = renderer.GetFrameCount(itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = lines[i].split(/\s(.+)/)[1];
			names.item[itemData.name] = id;
		}

		i++;
	}

	// store item data
	item[id] = itemData;

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetDrawingSource(drwId, frameList);

	return i;
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2,
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
	}

	return drawingData;
}

function parseScript(lines, i, backCompatPrefix, compatibilityFlags) {
	var id = getId(lines[i]);
	id = backCompatPrefix + id;
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	dialog[id] = { src: results.script, name: null, id: id, };

	if (compatibilityFlags.convertImplicitSpriteDialogIds) {
		// explicitly hook up dialog that used to be implicitly
		// connected by sharing sprite and dialog IDs in old versions
		if (sprite[id]) {
			if (sprite[id].dlg === undefined || sprite[id].dlg === null) {
				sprite[id].dlg = id;
			}
		}
	}

	i = results.index;

	return i;
}

function parseDialog(lines, i, compatibilityFlags) {
	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, "", compatibilityFlags);

	if (lines[i].length > 0 && getType(lines[i]) === "NAME") {
		dialog[id].name = lines[i].split(/\s(.+)/)[1]; // TODO : hacky to keep copying this regex around...
		names.dialog[dialog[id].name] = id;
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(lines, i, compatibilityFlags) {
	return parseScript(lines, i, "end_", compatibilityFlags);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(tileId, x, y) {
	bitsyDrawBegin(0);
	bitsyDrawTile(tileId, x, y);
	bitsyDrawEnd();
}

function drawSprite(tileId, x, y) {
	drawTile(tileId, x, y);
}

function drawItem(tileId, x, y) {
	drawTile(tileId, x, y);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	bitsyDrawBegin(0);
	bitsyClear(tileColorStartIndex);
	bitsyDrawEnd();
}

function drawRoom(room, frameIndex) { // frameIndex is optional
	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	bitsyLog("DRAW ROOM " + debugLastRoomDrawn);
	// }

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	// clear the screen buffer
	bitsyDrawBegin(0);
	bitsyClear(tileColorStartIndex);
	bitsyDrawEnd();

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			var x = parseInt(j);
			var y = parseInt(i);

			if (id != "0") {
				//bitsyLog(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// bitsyLog(id);
					drawTile(getTileFrame(tile[id], frameIndex), x, y);
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	bitsyLog("EXIT DIALOG!");

	isDialogMode = false;

	if (isNarrating) {
		isNarrating = false;
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	bitsyLog("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	startDialog(
		dialog[ending.id].src,
		ending.id,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsyLog("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;
	// bitsyLog("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	// bitsyLog("START DIALOG ");
	if (dialogStr.length <= 0) {
		// bitsyLog("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(null, dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );

/* EVENTS */
bitsyOnUpdate(update);
bitsyOnQuit(stopGame);
bitsyOnLoad(load_game);
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 1
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 2
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 3
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 4
000000
000000
001010
001110
001110
000100
000000
000000
CHAR 5
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 6
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 7
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 10
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 11
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 12
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 13
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 14
000011
001101
001011
001101
001011
011011
011000
000000
CHAR 15
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 16
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 17
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 18
000100
001110
011111
000100
011111
001110
000100
000000
CHAR 19
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 20
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 21
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 22
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 23
000100
001110
011111
000100
011111
001110
000100
001110
CHAR 24
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 25
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 26
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 27
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 28
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 29
000000
001010
001010
011111
001010
001010
000000
000000
CHAR 30
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 31
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
001010
010100
000000
000000
000000
000000
000000
000000
CHAR 127
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 128
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 129
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 130
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 131
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 132
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 133
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 134
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 135
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 136
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 137
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 138
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 139
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 140
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 141
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 142
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 143
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 144
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 145
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 146
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 147
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 148
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 149
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 150
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 151
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 152
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 153
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 154
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 155
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 156
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 157
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 158
011000
010100
010100
011010
010111
010010
010010
000000
CHAR 159
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 160
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 161
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 162
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 163
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 164
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 165
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 166
001110
000001
001111
010001
001111
000000
001111
000000
CHAR 167
001100
010010
010010
010010
001100
000000
011110
000000
CHAR 168
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 169
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 170
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 171
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 172
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 173
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 174
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 175
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 176
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 177
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 178
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 179
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 180
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 183
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 184
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 185
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 186
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 187
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 188
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 189
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 190
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 191
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 192
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 193
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 194
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 195
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 196
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 197
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 198
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 199
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 200
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 201
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 202
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 203
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 204
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 205
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 206
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 207
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 208
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 209
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 210
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 211
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 212
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 213
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 214
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 215
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 216
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 217
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 218
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 219
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 220
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 221
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 222
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 223
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 224
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 225
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 226
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 227
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 230
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 231
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 232
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 233
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 234
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 235
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 236
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 237
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 238
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 239
000000
001100
010010
010010
010010
010010
000000
000000
CHAR 240
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 241
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 242
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 243
000000
000000
111111
111000
100110
100001
100000
111111
CHAR 244
000000
000000
111111
000111
011001
100001
000001
111111
CHAR 245
000100
000100
000100
000100
000100
010100
001000
000000
CHAR 246
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 247
111110
111110
111110
111110
111110
111110
111110
111110
CHAR 248
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 249
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 250
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 251
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 252
001010
000000
010010
010010
010010
010110
001010
000000
CHAR 253
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 254
000000
000000
000000
011110
110010
110011
111110
001111
CHAR 255
010010
111111
010010
010010
111111
010010
000000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>